<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Go Context包源码解读 | Keiichi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="什么是context123456type Context interface &#123;   Deadline() (deadline time.Time, ok bool)   Done() &lt;-chan struct&#123;&#125;   Err() error   Value(key any) any&#125; Context本质上是一个接口，实现这四个方法的都可以被称作co">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Context包源码解读">
<meta property="og:url" content="http://example.com/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="Keiichi&#39;s blog">
<meta property="og:description" content="什么是context123456type Context interface &#123;   Deadline() (deadline time.Time, ok bool)   Done() &lt;-chan struct&#123;&#125;   Err() error   Value(key any) any&#125; Context本质上是一个接口，实现这四个方法的都可以被称作co">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-01T03:01:25.000Z">
<meta property="article:modified_time" content="2024-06-24T03:25:56.015Z">
<meta property="article:author" content="Keiichi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Keiichi's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keiichi&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Go Context包源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2023-12-01T03:01:25.000Z" itemprop="datePublished">2023-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Go Context包源码解读
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是context"><a href="#什么是context" class="headerlink" title="什么是context"></a>什么是context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context本质上是一个接口，实现这四个方法的都可以被称作context"><a href="#Context本质上是一个接口，实现这四个方法的都可以被称作context" class="headerlink" title="Context本质上是一个接口，实现这四个方法的都可以被称作context"></a>Context本质上是一个接口，实现这四个方法的都可以被称作context</h4><h5 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline()"></a>Deadline()</h5><p>返回time.Time类型的context过期时间，和一个布尔值ok。若ok为false则该context未设置过期时间 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Deadline())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">fmt.Println(c1.Deadline())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">0001</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC <span class="literal">false</span></span><br><span class="line"><span class="number">2023</span><span class="number">-11</span><span class="number">-28</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">59.2174603</span> +<span class="number">0800</span> CST m=+<span class="number">3.002624401</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h5><p>返回一个channel，当context关闭时，channel会关闭。如果context永远不会关闭，则会返回nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Done())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1.Done():</span><br><span class="line">   fmt.Println(<span class="string">&quot;context过期，channel关闭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context过期，channel关闭</span><br></pre></td></tr></table></figure>
<h5 id="Err"><a href="#Err" class="headerlink" title="Err()"></a>Err()</h5><p>返回一个error类型错误，没错误则返回nil，一般只有context超时和被关闭时则会返回error</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background()                      <span class="comment">//创建个空context</span></span><br><span class="line">c1, _ := context.WithTimeout(c, <span class="number">1</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">c2, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second)</span><br><span class="line">cancel()</span><br><span class="line">fmt.Println(c2.Err())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 （context超时和被取消的返回的error不一样）</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context deadline exceeded</span><br><span class="line">context canceled</span><br></pre></td></tr></table></figure>
<h5 id="Value-key-any"><a href="#Value-key-any" class="headerlink" title="Value(key any)"></a>Value(key any)</h5><p>类似map，输入key给出对应value。key通常在全局变量中分配，可返回任何类型的值。多次调用仍会返回相同值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">c1 := context.WithValue(c, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>) <span class="comment">//在context中设置一个键值对</span></span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Rose</span><br><span class="line">Rose</span><br><span class="line">Rose</span><br></pre></td></tr></table></figure>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><h5 id="取消错误"><a href="#取消错误" class="headerlink" title="取消错误"></a>取消错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当context被cancel函数关闭时调用<code>Err()</code>就会返回该错误</p>
<h5 id="超时错误"><a href="#超时错误" class="headerlink" title="超时错误"></a>超时错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此错误被集合成了一个结构体，通过调用其的三个方法来反映错误和获取信息</p>
<h2 id="EmptyContext"><a href="#EmptyContext" class="headerlink" title="EmptyContext"></a>EmptyContext</h2><h4 id="最简单的一个context"><a href="#最简单的一个context" class="headerlink" title="最简单的一个context"></a>最简单的一个context</h4><p>没有过期时间和信息，用来当作父context或者其他需求，通过其不断延伸</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="emptyCtx其他方法"><a href="#emptyCtx其他方法" class="headerlink" title="emptyCtx其他方法"></a>emptyCtx其他方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">   todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> e &#123;</span><br><span class="line">   <span class="keyword">case</span> background:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">   <span class="keyword">case</span> todo:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Background和Todo"><a href="#Background和Todo" class="headerlink" title="Background和Todo"></a>Background和Todo</h5><p>都是emptyCtx，本质上是一样，只是人为区分他们，将他们用作不同途径。  </p>
<ul>
<li>Background 返回一个非 nil、空的 Context。它永远不会被取消，没有价值，也没有截止日期。它通常由 main 函数、初始化和测试使用，并用作传入请求的顶级 Context。  </li>
<li>TODO 返回一个非 nil 的空 Context。代码应使用上下文。当不清楚要使用哪个 Context 或尚不可用时，就使用 TODO（因为周围函数尚未扩展为接受 Context 参数）。</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h5><p>该方法用来判断该emptyCtx是Background还是Todo</p>
<h2 id="cancel相关"><a href="#cancel相关" class="headerlink" title="cancel相关"></a>cancel相关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CancelCauseFunc <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CancelFunc与CancelCauseFunc"><a href="#CancelFunc与CancelCauseFunc" class="headerlink" title="CancelFunc与CancelCauseFunc"></a>CancelFunc与CancelCauseFunc</h5><ul>
<li>CancelFunc不需要参数</li>
<li>CancelCauseFunc需要error类型的参数<br>他们都是函数的别名，起别名是为了方便后面阅读和使用</li>
</ul>
<h5 id="WithCancel与WithCancelCause"><a href="#WithCancel与WithCancelCause" class="headerlink" title="WithCancel与WithCancelCause"></a>WithCancel与WithCancelCause</h5><ul>
<li>区别是Cause的携带</li>
<li>他们通过withCancel创建一个context，并返回该context和取消函数，下面以WithCancelCause为例，他返回如下的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br></pre></td></tr></table></figure>
cause是错误原因，然后这个函数调用新创建的cancelCtx的cancel方法，完成了取消操作。cancel需要参数如下，上面传入的第二个参数是<code>Canceled</code>，就是先前定义的一个错误<code>&quot;context canceled&quot;</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
后面再细讲cancel</li>
</ul>
<h2 id="创建cancelCtx"><a href="#创建cancelCtx" class="headerlink" title="创建cancelCtx"></a>创建cancelCtx</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withCancel</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   c := newCancelCtx(parent)</span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数需要一个父context，如果传入的是nil则会panic掉<br>继续往下看会发现出现新的函数<code>newCancelCtx</code>，我们看看它会传给我们什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给我们返回了一个包含父context的<code>cancelCtx</code>的指针，那么<code>cancelCtx</code>长什么样呢，继续跟过去</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">   done     atomic.Value          </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">   err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">   cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见里面有</p>
<ul>
<li><code>mu</code>：锁，用来保护临界资源</li>
<li><code>done</code>：atomic包里的value类型的值，原子性我们直接看看源码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Value 提供原子加载和一致类型化值的存储。</span></span><br><span class="line"><span class="comment">//Value 的零值从 Load 返回 nil。调用 Store 后，不得复制 Value。首次使用后不得复制 Value。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">   v any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>children</code>：字段是一个map，用于保存这个context派生出去的所有子context和它们对应的canceler。其中，<code>canceler</code>接口定义如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）"><a href="#canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）" class="headerlink" title="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）- err：错误信息- cause:错误原因（差不多吧这两个）    "></a><code>canceler</code>接口中有方法<code>cancel</code>，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的<code>cancel</code>方法将自己也取消掉，并将自己从父context的<code>children</code>字段中移除。<br>因此，<code>cancelCtx</code>中的<code>children</code>字段实际上是用来记录这个context的所有子context以及它们对应的<code>canceler</code>对象。当这个context被取消时，它会遍历所有的子context并调用它们的<code>cancel</code>方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）<br>- <code>err</code>：错误信息<br>- <code>cause</code>:错误原因（差不多吧这两个）    </h2><p>现在我们已经知道什么是cancelCtx了，那么回到原函数<code>withCanel</code>上来，<code>newCancelCtx</code>之后是<code>propagateCancel</code>函数，<strong>它的作用是将child添加到parent的children里面</strong>，让我们看看它的源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// parent永远无法取消则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第16行又出现了<code>parentCancelCtx</code>函数，该函数作用是查找最近的父cancelCtx</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>closedchan</code>在源码中是这样定义的，所以正如其名，他是个关闭的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"><a href="#所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下" class="headerlink" title="所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当&amp;cancelCtxKey作为参数则会返回该cancelCtx可是func (c *cancelCtx) Value(key any) any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"></a>所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false<br>之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br></pre></td></tr></table></figure><br>是什么含义呢？<br>我们再去看看Value方法是怎么处理这个的<br>经过查找我们发现cancelCtx重写了Value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当<code>&amp;cancelCtxKey</code>作为参数则会返回该cancelCtx<br>可是<code>func (c *cancelCtx) Value(key any) any</code>是如何获取到最近的canncelCtx呢？<br>如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx<br>如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>现在让我们回到<code>parentCancelCtx</code>函数上来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时已经通过parent.Value获取到了最近的cancelCtx并传给变量p了（没有找到就return nil了）<br>然后，通过p.done.Load()拿到一个管道（p.done是atomic.Value类型，在atomic包里有它的Load方法），<br>现在讲拿到的管道（最近的cancelCtx的管道）和之前的管道作比较（parent的管道），如果不是同一个就返回nil,<strong>这个情况代表你找到了最近的自定义cancelCtx但是并不是包定义的cancelCtx</strong>    </p>
<p>当一切都判定过去后，我们就成功拿到了最近的cancelCtx，现在我们终于可以回到<code>propagateCancel</code>函数了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// 如果分支上不存在可cancel的context则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到后先上个锁，再将child放到children的key里    </p>
<p><strong>那map中的值struct{}是拿来干什么？</strong><br>实际上是因为使用空结构体<code>struct&#123;&#125;</code>作为值的好处在于它占用极少的内存空间，实际上不占用任何空间。这是因为在Go语言中，空结构体的大小是0字节。通过将空结构体作为值，我们可以实现一个只关注键的集合，而不需要额外的内存开销。  </p>
<p>如果没有拿到，则开启一个协程来监听parent和child管道状态，若parent取消则child取消掉自己，若child先取消则不做为，当两个都没取消掉这个协程就会一直阻塞在这里，直到其中一个先cancel掉  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goroutines.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">   <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>到此为止，一个cancelCtx就被成功创建出来了</p>
<h2 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h2><p>直接看看源码，它的作用是，从最近的父cancelCtx的children中移除child</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   p, ok := parentCancelCtx(parent)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入一个父Ctx（不知道类型），然后根据此ctx查找最近的父cancelCtx，没有找到就return<br>找到就调用其锁，删掉children中的child这个key，再解锁  </p>
<h2 id="canceler定义"><a href="#canceler定义" class="headerlink" title="canceler定义"></a>canceler定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">   cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有cancel方法（后面讲）和Done方法的都是canceler，可以看到我们所有的cancelCtx都满足这个条件，所以每个cancelCtx实际上也是一个canceler</p>
<h2 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h2><p>cancelCtx的定义在之前已经提到过了，我们主要讲讲cancelCtx重写父Ctx的方法，就在代码旁批注解释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            </span><br><span class="line">   done     atomic.Value         </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">   err      <span class="type">error</span>                </span><br><span class="line">   cause    <span class="type">error</span>                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果传进来的key是实现设立的cancelCtxKey则返回该cancelCtx本身</span></span><br><span class="line"><span class="comment">//如果不是就会一直往上找，调用该ctx存储的父ctx的信息查看key对应value的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;   </span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">//done是atomic.Value类型，负责原子性存储</span></span><br><span class="line"><span class="comment">//先把done里的东西通过Load取出来</span></span><br><span class="line">   d := c.done.Load()     </span><br><span class="line">   <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;          </span><br><span class="line">      <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果done里啥都没有就上锁（关门打狗）</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//再次调用Load读取，目的是再次检查context有无被取消</span></span><br><span class="line">   d = c.done.Load()</span><br><span class="line">   <span class="comment">//done里确实啥也没有，就给他创建一个，然后存进去</span></span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;   </span><br><span class="line">      d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">      c.done.Store(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁读取err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   err := c.err</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String接口有关"><a href="#String接口有关" class="headerlink" title="String接口有关"></a>String接口有关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">   String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为接口定义，在各种string方法中均有contextName函数的出现，让我们看看这是什么吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contextName</span><span class="params">(c Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> s, ok := c.(stringer); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> s.String()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reflectlite.TypeOf(c).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将传入的<code>c</code>做类型断言，如果<code>c</code>是<code>stringer</code>接口类型就调用<code>c</code>的<code>String</code>方法<br>如果不是就返回用字符串表示的<code>c</code>的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123; 	</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">      c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">      time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">      reflectlite.TypeOf(c.key).String() +</span><br><span class="line">      <span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个String方法都是返回字符串类型的Ctx的信息</p>
<h2 id="cancel函数"><a href="#cancel函数" class="headerlink" title="cancel函数"></a>cancel函数</h2><p>这个函数已经在之前出现很多次了，现在我们来详细讲讲</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入err，则panic（可能是误操作的cancel，出现重大问题，直接panic掉）</span></span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; </span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果传入了err但是没有cause，就把err赋值给cause，原因就是err</span></span><br><span class="line">   <span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">      cause = err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//之后要对Ctx里的数据操作，先上把锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="comment">//如果Ctx已经被cancel掉就开锁退出</span></span><br><span class="line">   <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">   &#125;</span><br><span class="line">   c.err = err</span><br><span class="line">   c.cause = cause</span><br><span class="line">   <span class="comment">//关掉ctx中的管道</span></span><br><span class="line">   d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.done.Store(closedchan)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">close</span>(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历ctx的子ctx，一个一个取消，最后该分支下的全被取消掉</span></span><br><span class="line">   <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">      child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   &#125;</span><br><span class="line">   c.children = <span class="literal">nil</span></span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="comment">//是否要从父ctx移除该ctx，如果传入的是就移除</span></span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timerCtx</code>重写了该方法，主要通过调用父cancelCtx的cancel方法并删掉timer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.cancelCtx.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//它的锁是用的父cancelCtx的锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer.Stop()</span><br><span class="line">      c.timer = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   *cancelCtx</span><br><span class="line">   timer *time.Timer </span><br><span class="line"></span><br><span class="line">   deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建带有过期时间的Ctx"><a href="#创建带有过期时间的Ctx" class="headerlink" title="创建带有过期时间的Ctx"></a>创建带有过期时间的Ctx</h2><p>传入一个Ctx和时限，返回一个Ctx和取消它的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入parent，则报错</span></span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取parent过期时间，若获取成功且此时间在设定的时间之前，那么就听parent的话，与其同时过期</span></span><br><span class="line">   <span class="comment">//调用WithCancel，此函数会返回一个cancelCtx和取消函数</span></span><br><span class="line">   <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">      <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果没有获取到parent过期时间或者获取到的时间已经过了设定时间</span></span><br><span class="line">   <span class="comment">//就创建一个timerCtx，赋予过期时间为设定的时间</span></span><br><span class="line">   c := &amp;timerCtx&#123;</span><br><span class="line">      cancelCtx: newCancelCtx(parent),</span><br><span class="line">      deadline:  d,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建完后要填到parent的children里</span></span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   dur := time.Until(d)</span><br><span class="line">   <span class="comment">//如果已经超时，就cancel掉此ctx并从它的parent的children里移除</span></span><br><span class="line">   <span class="comment">//再返回该ctx（？？？不理解这点，拿这个剥离出来的cancel掉的ctx干啥）</span></span><br><span class="line">   <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//锁住这个ctx</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//如果该ctx还没被cancel就等到设定时间调用cancel</span></span><br><span class="line">   <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数就是WithDeadline的一个补充函数，它传入的是时间段，WithDeadline传入的是时间点，效果一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ValueCtx相关"><a href="#ValueCtx相关" class="headerlink" title="ValueCtx相关"></a>ValueCtx相关</h2><p>ValueCtx只负责携带Key-Value键值对，其他交给父Ctx做</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line">   key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建value"><a href="#创建value" class="headerlink" title="创建value"></a>创建value</h3><p>没啥好说的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查这个key能不能作比较，如果不能就不能拿它当key</span></span><br><span class="line">   <span class="comment">//为什么呢，因为如果key不能比较，我们就无法通过查找key来拿到对应的value</span></span><br><span class="line">   <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取value"><a href="#获取value" class="headerlink" title="获取value"></a>获取value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="comment">//能直接拿到就拿</span></span><br><span class="line">   <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">      <span class="keyword">return</span> c.val</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//不能就往上找</span></span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h3><p>这个就像一个方法合集，通过对传入的ctx类型判断来调用相应的方法，如果在当前ctx无法取到值就会一直往上找</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我第一次阅读源码，虽然context包很简单，但是我读起来真的好吃力<br>读着读着总会惊叹写这些代码的人脑子是怎么长的？vocal为什么能写的那么优雅，有些奇思妙想真的好牛 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clxsf5n7d00017c87an8hbogd" data-title="Go Context包源码解读" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/02/08/Web%E4%B8%9A%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Web业务项目基本目录结构
        
      </div>
    </a>
  
  
    <a href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Go简单计算器的实现</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/10/%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/">在数据库中存入自定义类型</a>
          </li>
        
          <li>
            <a href="/2024/07/23/Go%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BA%93-base64Chaptcha%E7%9A%84%E4%BD%BF%E7%94%A8/">Go图形验证码库-base64Chaptcha的使用</a>
          </li>
        
          <li>
            <a href="/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">再遇跨域问题</a>
          </li>
        
          <li>
            <a href="/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/">正则表达式笔记</a>
          </li>
        
          <li>
            <a href="/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/">go算法小抄</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Keiichi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>