<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Keiichi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="My Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Keiichi&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Keiichi&#39;s blog">
<meta property="og:description" content="My Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keiichi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Keiichi's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keiichi&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Go简单计算器的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-10-29T00:31:12.000Z" itemprop="datePublished">2023-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">Go简单计算器的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算器实现原理"><a href="#计算器实现原理" class="headerlink" title="计算器实现原理"></a>计算器实现原理</h2><p>我们平时见到的算式都是这种类型 <code>1+(2+3)*4</code>，这种类型的表达式也被称为中缀表达式，我们很容易理解它的运算顺序。但是计算机却无法理解这个式子<br>因此我们需要将其转化为便于计算机理解的式子，转化为后缀表达式或者前缀表达式（其实都差不多）。在这里我们以后缀表达式为例子。</p>
<h3 id="中缀表达式如何转化为后缀表达式"><a href="#中缀表达式如何转化为后缀表达式" class="headerlink" title="中缀表达式如何转化为后缀表达式"></a>中缀表达式如何转化为后缀表达式</h3><p><code>1+(2+3)*4</code>的后缀表达式为<code>123+4*+</code>，前者转换成后者的过程需要利用到栈和队列这两个数据结构，不太清楚可以看看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113852222">栈和队列详解</a>  </p>
<p>首先我们需要一个栈和队列</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81eab9f9deaf4aa0a489093ad592e77c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=602&s=62839&e=png&b=fdfdfd" alt="image.png"><br>然后从左到右依次根据一定规则判断是否入栈  </p>
<p>  入栈规则如下：  </p>
<ul>
<li><p>数字直接入队列</p>
</li>
<li><p>若是运算符，则判断其与栈顶符号的优先级，优先级低于或等于栈顶符号，栈内元素不断出栈，进入队列，直到栈空或者碰见左括号为止</p>
</li>
<li><p>若是左括号则直接入栈</p>
</li>
<li><p>若是右括号则栈内所有元素出栈，进入队列，直到遇见与之匹配的左括号</p>
</li>
<li><p>最后栈内所有元素按顺序入列</p>
<p>现在我们开始进行变换</p>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce14ec22c9b54ed29e7a625bbd614321~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=554&s=56982&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b332167d6864fc1b4fe540821e36187~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=559&s=56608&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be4fa1d786a42409fb3baf6711bba29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=923&h=587&s=57280&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2829f96842340779a589c8345b775d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=939&h=574&s=57307&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8cb753ed6264c2e82b3ab778fb50b36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=853&h=581&s=49855&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f7bf41a67f74a12adc2d8b53863fca5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=805&h=586&s=46212&e=png&b=fdfdfd" alt="image.png"><br>最后得到我们的结果<code>123+4*+</code>中缀就成功转化成后缀表达式了</p>
<h3 id="计算机是如何理解后缀表达式的？"><a href="#计算机是如何理解后缀表达式的？" class="headerlink" title="计算机是如何理解后缀表达式的？"></a>计算机是如何理解后缀表达式的？</h3><p>计算机会将之前放在队列里的元素按照先进先出(FIFO)的规则，将元素弹出进行判断<br>如果元素为数字，则直接入栈，若元素为运算符，则从栈中弹出两个数字进行运算，再将运算结果放入栈中<br>当队列全部元素取出后，最后栈中剩下的唯一一个元素就是我们要找的结果了</p>
<h2 id="在GO中的实现"><a href="#在GO中的实现" class="headerlink" title="在GO中的实现"></a>在GO中的实现</h2><p>首先我们需要创造出我们的工具：栈和队列</p>
<h3 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;      <span class="comment">//定义栈</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;  <span class="comment">//因为储存的元素是空接口类型，所以之后要注意类型断言和类型转化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;   <span class="comment">//返回一个栈</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断栈是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123; <span class="comment">//将元素入栈</span></span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将栈顶元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//只查询栈顶元素，不弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;       <span class="comment">//定义队列</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;   <span class="comment">//返回一个队列</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;   <span class="comment">//将元素压入队列</span></span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将最先进入的元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀转后缀实现"><a href="#中缀转后缀实现" class="headerlink" title="中缀转后缀实现"></a>中缀转后缀实现</h3><p>按照先前的规则，灵活运用判断语句实现中缀到后缀表达式的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算过程的实现"><a href="#计算过程的实现" class="headerlink" title="计算过程的实现"></a>计算过程的实现</h3><p>逻辑十分简单，主要注意的是类型间的转化，要从空接口类型断言为string类型，再将string类型转化为int类型进行计算，使用float类型也可以实现小数计算，可以自己去尝试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 实现栈</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue 实现队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterToNum</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   str := i.(<span class="type">string</span>)</span><br><span class="line">   ret, _ := strconv.Atoi(str)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;输入规则:&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;1.可输入加减乘除以及小括号&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;2.只能输入正整数&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;3.输入exit退出&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">      fmt.Printf(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line">      scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">      scanner.Scan() <span class="comment">// 读取输入内容，直到遇到换行符（包括空格）</span></span><br><span class="line">      input := scanner.Text()</span><br><span class="line">      <span class="keyword">if</span> input == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      S := NewStack()</span><br><span class="line">      Q := NewQueue()</span><br><span class="line">      err := Transform(S, Q, input)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">      ret := Calculate(S, Q)</span><br><span class="line">      fmt.Println(<span class="string">&quot;结果为: &quot;</span>, ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>以上只实现了正整数之间的加减乘除和小括号的运算，图方便未考虑其他可左右运算顺序的符号如：<code>[]中括号 &#123;&#125;大括号 %取余</code>，除此之外还可以尝试一下实现输入负数时处理的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clxsf5n7a00007c87g2xbft88" data-title="Go简单计算器的实现" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git合作开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-10T05:05:31.000Z" itemprop="datePublished">2023-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/">Git合作开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h3><p>用一个通俗的理解就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p>分支在实际开发中的作用：在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，到最后再合并分支，就可以达到很好的结果。</p>
<h3 id="master-主分支"><a href="#master-主分支" class="headerlink" title="master 主分支"></a>master 主分支</h3><p>在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master （也有叫main） 的分支。通常我们把这个master 分支叫做主分支。</p>
<p>在实际工作中，master （也有叫main）主分支的作用是：用来保存和记录整个项目已完成的功能代码。因此，不允许程序员直接在 master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p>
<h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>由于程序员不能直接在 master 分支上进行功能的开发，所以就有了功能分支的概念。功能分支指的是专门用来开发新功能的分支，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。</p>
<p>上面介绍了分支的一些概念之后，下面就开始进入本地分支操作</p>
<h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><h3 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>注意：分支名字前面的 * 号表示当前所处的分支。</p>
<h3 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h3><p>使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支的名字</span><br></pre></td></tr></table></figure>


<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>使用如下的命令，可以切换到指定的分支上进行开发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名字</span><br></pre></td></tr></table></figure>

<p>注意到前面的 * 号已经改变位置</p>
<h3 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h3><p>如果我们输入命令创建了一个分支之后，又要输入一个切换分支的命令，就很麻烦，所以使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名字</span><br></pre></td></tr></table></figure>

<p>PS：<br>“git checkout -b 分支名称” 是下面两条命令的简写形式：</p>
<ul>
<li>git branch 分支名称</li>
<li>git checkout 分支名</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//假如在C分支</span><br><span class="line">//先切换到A分支</span><br><span class="line">git checkout A</span><br><span class="line">//此时在A分支，合并A，C分支</span><br><span class="line">git merge C</span><br></pre></td></tr></table></figure>

<p>合并分支时的注意点：假设要把 C 分支的代码合并到 A 分支，则必须先切换到 A 分支上，再运行 git merge 命令，来合并 C 分支！</p>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后手动解决冲突。</p>
<p>举个栗子，我们再master分支上修改了test_01.txt文件，写入了一段文字，并提交</p>
<p>我们再切换到另一个分支也写一段文字，也提交</p>
<p>最后回到master分支上，去合并test分支，发现有提示冲突</p>
<p>且直接打开文件什么都看不到</p>
<p>我用vscode打开发现两端不同颜色的字体，其实就是不同分支写入的东西，需要我们认为去解决，看到上面有四个选项可以自己点击，如果点错了可以ctrl+z撤回再选。选完之后保存，然后跟踪提交再合并就不会有冲突了。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除分支</span><br><span class="line">git branch -d xxx</span><br></pre></td></tr></table></figure>


<p>注意，删除分支不能在该分支上删除该分支，就好比自己在一艘船上要把船弄沉这一道理。所以要去到其他分支再去删除</p>
<h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><h3 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a>将本地分支推送到远程仓库</h3><p>如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名 本地分支名称: 远程分支名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//案例</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"></span><br><span class="line">//如果希望远程分支的名称和本地分支名称保持一直，可以对命令进行简化：</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure>

<p>注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支</p>
<h3 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h3><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从远程仓库中，把对应的远程分支下载到本地仓库，名字保持一致</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"></span><br><span class="line">//从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"></span><br><span class="line">//案例  把远程仓库origin里面的pay分支下载并重命名为payment分支</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure>

<h3 id="拉取远程分支的最新的代码"><a href="#拉取远程分支的最新的代码" class="headerlink" title="拉取远程分支的最新的代码"></a>拉取远程分支的最新的代码</h3><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从远程仓库，拉区当前分支的最新代码，保持当前分支的代码和远程分支的代码一致</span><br><span class="line">git pull </span><br></pre></td></tr></table></figure>

<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>可以使用如下的命令，删除远程仓库中指定的分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line">//案例</span><br><span class="line">git push origin--delete pay</span><br></pre></td></tr></table></figure>

<h2 id="同步项目"><a href="#同步项目" class="headerlink" title="同步项目"></a>同步项目</h2><p>Github 我们经常会通过 fork 开源项目在自己的仓库中更新，然后提交 Pull Request (Merge Request) 为开源项目做贡献。</p>
<p>不过我们经常会遇到原仓库更新，重新 fork 显然是不优雅的，那我我们该怎么同步更新呢？</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f0a77dd7d7a47761846668fe061c70b_720w.webp"></p>
<h2 id="如何在-Github-网页端同步更新？"><a href="#如何在-Github-网页端同步更新？" class="headerlink" title="如何在 Github 网页端同步更新？"></a>如何在 Github 网页端同步更新？</h2><ol>
<li>进入你自己的 fork 过来的仓库。</li>
<li>点击 “Pull requests” ，如何点击右侧绿色的 “New pull request”。</li>
<li>Github 首先会比较源仓库与你 fork 后的仓库，如果你没有做任何更改，则找不到要 PR 的内容。所以，我们需要点击 “switching the base”，会将我们的仓库作为基础版本，原仓库作为 head 版本，现在我们会看到我们的需要需要 “catch up” 的更新。</li>
<li>点击 “Create pull request”，起一个名字，然后点击 “Create pull request”。</li>
<li>点击 “Merge pull request”，然后点击 “Confirm merge”。</li>
<li>如果我们没提交什么新代码，merge 过程将自动完成。</li>
</ol>
<h2 id="如何通过本地命令行同步更新？"><a href="#如何通过本地命令行同步更新？" class="headerlink" title="如何通过本地命令行同步更新？"></a>如何通过本地命令行同步更新？</h2><ol>
<li>验证远程分支可以 fetch 或 push</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指明我们需要同步的仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/OriginalRepo/OriginalProject.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>拉取更新的 branches 和 commits</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Checkout 本地分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>合并</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>提交</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/" data-id="clyfhaq4t00011487fgjnbxn5" data-title="Git合作开发" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/07/Redis%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-07T13:59:56.000Z" itemprop="datePublished">2023-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/07/Redis%E7%AC%94%E8%AE%B0/">Redis笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><p><code>auth [username] password</code>  默认用户是<code>default</code></p>
<p><code>dbsize</code> 查看数据库key数量、</p>
<p><code>select index</code> 选择数据库，默认是0(即<code>select 0</code>)</p>
<p><code>help @基本数据类型</code> 查看命令</p>
<p><code>flushall</code> 删除所有key</p>
<p><code>keys *</code> 查看所有key</p>
<p><code>exit</code> or <code>quit</code> 退出命令行</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p>
<p><strong>底层实现：</strong>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h5><p>语法 (不强制大小写)</p>
<p><code>SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]</code></p>
<p><strong>EX</strong>:表明过期时间，单位是秒 和 <strong>setex</strong> 相同</p>
<p><strong>PX</strong>:单位毫秒</p>
<p><strong>EXAT</strong>:设置时间到某个时间戳（秒级）</p>
<p><strong>PXAT</strong>:设置时间到某个时间戳（毫秒级）</p>
<p><strong>NX</strong> ：当键k不存在时，设置键；设置成功返回ok，不成功时返回nil；和<strong>SETNX</strong>等价</p>
<p><strong>XX</strong>： 与NX相反只在键已经存在时， 才对键进行设置操作</p>
<p><strong>GET</strong>: 返回之前设的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET wx 666</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET wx</span><br><span class="line">&quot;666&quot;</span><br><span class="line">127.0.0.1:6379&gt; TTL wx</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ttl</strong> 查看Key的过期时间(ms) -1是永久 -2是不存在或着已过期</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET wx 666  EX 666</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; TTL wx</span><br><span class="line">(integer) 662</span><br><span class="line">127.0.0.1:6379&gt; SET wx 666 EXAT 1668931126576</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; TTL wx</span><br><span class="line">(integer) 1667262367568</span><br><span class="line">127.0.0.1:6379&gt; SET wx 666 PXAT 1668931126576</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><strong>XX与NX选项</strong>: NX当键k不存在时，设置键 ; XX则在这个k存在时设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET wx 999  NX</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; SET yxh 999 NX</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET yxh</span><br><span class="line">&quot;999&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET wx</span><br><span class="line">&quot;666&quot;</span><br><span class="line">127.0.0.1:6379&gt; SET wx 999 XX</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET wx</span><br><span class="line">&quot;999&quot;</span><br></pre></td></tr></table></figure>

<p>GET 会返回之前的value 如果key不存在SET不会失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET yxh 999</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET yxh 1 GET</span><br><span class="line">&quot;999&quot;</span><br><span class="line">127.0.0.1:6379&gt; SET lmj 1 GET</span><br><span class="line">(nil)  </span><br><span class="line">127.0.0.1:6379&gt; GET lmj</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h5><p>语法: <code>setex key seconds value</code></p>
<p>和 set key value ex 一样</p>
<p>PSETEX</p>
<p>语法：<code>psetex key milliseconds value</code></p>
<p>和 set key value px 一样</p>
<p>MSET</p>
<p>语法： <code>MSET key value [key value ...]</code></p>
<p>同时设置多个键值对 返回OK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET wx  1 lmj 2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>MGET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MGET wx  lmj</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>MSETNX</p>
<p>语法：<code>msetnx key value [key value ...]</code></p>
<p>msetnx a 1 b 2 c 3 批量设置键值对，当所有key都不存在时返回1，否则返回0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx a 1 b 2 c 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; msetnx a 1 b 2 c 3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>语法：<code>GET key</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET lmj</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="GETEX"><a href="#GETEX" class="headerlink" title="GETEX"></a>GETEX</h5><p>语法：<code>GETEX key [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|PERSIST]</code></p>
<ul>
<li>用于获取k的值，并设置或者移除过期时间，参数类似于set</li>
<li>EX,PX,EXAT,PXAT 和set的相同</li>
<li>PERSIST移除k的过期时间</li>
</ul>
<p>相当于或值并且重新设置过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETEX lmj EX 1</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET lmj</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>GETSET</p>
<p>语法 <code>getset key value</code></p>
<p>和 set key value get 相同</p>
<p>GETRANGE</p>
<p>语法：<code>getrange key start end</code></p>
<p>截取字符串 下标从0开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange lanshan 0 2</span><br><span class="line">&quot;lan&quot;</span><br></pre></td></tr></table></figure>

<p>SETRANGE</p>
<p>语法： <code>setrange key offset value</code></p>
<p>setrange 用value从偏移量（offset）开始(包括offset)，覆盖key的值</p>
<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange key 2 def</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;abdef&quot;</span><br></pre></td></tr></table></figure>

<p>STRLEN</p>
<p>语法 <code>strlen key</code></p>
<p>strlen key 返回键key存储的值的长度，<strong>不存在的k返回0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; strlen lmj</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>INCR</p>
<p>语法<code>incr key</code></p>
<p>incr 对key的值加1，并返回加1后的结果；如果k的值是字符串，无法加1，则提示错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; set k wx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>

<p>INCRBY</p>
<p>语法 <code>incrby key increment</code></p>
<p>类似 INCR 只不过可以设置任意数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby k  2</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure>

<p>INCRBYFLOAT</p>
<p>语法：<code>incrbyfloat key increment</code></p>
<p>增加浮点值或者加整型值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;0.3&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k 0.2</span><br><span class="line">&quot;0.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k 1</span><br><span class="line">&quot;1.5&quot;</span><br></pre></td></tr></table></figure>

<p>DECR</p>
<p>语法 <code>decr key</code></p>
<p>值减一 类似incr</p>
<p>DECRBY</p>
<p>语法 : <code>decrby key decrement</code></p>
<p>自定义减值 类似incrby</p>
<p>APPEND</p>
<p>语法 <code>append key value</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 12</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append k 345</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure>

<p><strong>DEL</strong></p>
<p>语法 <code>del key</code> 删除值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del k</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>缓存对象</p>
<p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;wxgg&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name wxgg user:1:age 18 user:2:name wxjj user:2:age 18</code>。</li>
</ul>
<p>常规计数</p>
<p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>分布式锁</p>
<p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>Hash 是一个键值对（key - value）集合，其中 value 的形式入： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p>
<p>内部实现</p>
<p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack (紧凑列表)数据结构来实现了</strong>。</p>
<p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h5><p>语法 <code>hset key field value</code></p>
<p>一个key的值可以有多个 field但一个 field只能有一个 value 可以和 go中的map 一起理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset gocybee wx 666</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset gocybee yxh 666</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h5><p>语法 <code>hsetnx key field value</code></p>
<p>设置哈希的一个字段，当指定的字段不存在时才会被设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset wx age 18</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx wx age 18</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx wx weight 70</span><br><span class="line">(integer) 1</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>在上面的命令中，age 字段已经存在于 wx这个 key 中，因此 hsetnx 命令的执行并没有添加或修改 age，而 weight 在 wx这个 key 中是不存在的，因此 weight 被添加到 wx中。</p>
<h5 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h5><p>语法： <code>hmset key field value [field value ...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset wx age 18  weight 60</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h5><p>语法：  <code>hget key field</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget wx age</span><br><span class="line">&quot;18&quot;</span><br></pre></td></tr></table></figure>

<h5 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h5><p>获取哈希的所有字段的值，该命令的用法如下：</p>
<p><code>hgetall key</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall wx</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;18&quot;</span><br><span class="line">3) &quot;weight&quot;</span><br><span class="line">4) &quot;60&quot;</span><br></pre></td></tr></table></figure>

<p>前一个是field 后面是value</p>
<h5 id="HkEYS"><a href="#HkEYS" class="headerlink" title="HkEYS"></a>HkEYS</h5><p>语法：<code>hkeys key</code></p>
<p>该命令的作用是：获取哈希的所有字段，但是不获取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys wx</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;weight&quot;</span><br></pre></td></tr></table></figure>

<h5 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h5><p>语法：<code>hexists key field</code></p>
<p>该命令的作用是：判断字段是否存在于指定哈希中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists wx age</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists wx tall</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h5 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h5><p>语法： <code>hlen key</code></p>
<p>获取指定哈希中字段的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen wx</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h5 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h5><p>语法 ：  <code>hmget key field [field ...]</code></p>
<p>获取指定哈希中的多个字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget wx age weight</span><br><span class="line">1) &quot;18&quot;</span><br><span class="line">2) &quot;60&quot;</span><br></pre></td></tr></table></figure>

<h5 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h5><p>语法 ： <code>hstrlen key field</code></p>
<p>该命令的作用是：获取指定哈希中字段的长度，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen wx age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h5 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h5><p>语法： <code>hvals key</code></p>
<p>该命令的作用是：获取指定哈希的所有值，不获取字段名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals wx</span><br><span class="line">1) &quot;18&quot;</span><br><span class="line">2) &quot;60&quot;</span><br></pre></td></tr></table></figure>

<h5 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h5><p>语法： <code>hincrby key field increment</code></p>
<p>和 incryby类似 将指定哈希中的指定字段的值加一个指定的整型值</p>
<h5 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h5><p>语法： <code>hincrbyfloat key field increment</code></p>
<p>将指定哈希中的指定字段的值加一个指定的浮点型值 也可以加整型值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrbyfloat wx age 0.5</span><br><span class="line">&quot;18.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget wx age</span><br><span class="line">&quot;18.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat wx age 1</span><br><span class="line">&quot;19.5&quot;</span><br></pre></td></tr></table></figure>

<h5 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h5><p>语法: <code>hdel key</code></p>
<p>删除哈希中指定一个或多个字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel wx b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys wx</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;weight&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel wx age weight</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; hkeys wx</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h5><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>lmj</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>wx</td>
<td>18</td>
</tr>
<tr>
<td>3</td>
<td>yxh</td>
<td>18</td>
</tr>
</tbody></table>
<p>我们可以这样来存储对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HSET uid:1 name lmj age 18</span><br><span class="line">HSET uid:2 name wx  age 18</span><br><span class="line">HSET uid:3 name yxh age 18</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p>
<p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素。</p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist（快速表） 实现了，替代了双向链表和压缩列表</strong>。</p>
<h4 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h5><p>语法：  <code>lpush key element [element ...]</code></p>
<p>当key存在但是却不是列表会返回错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush gocybee 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<h5 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h5><p>语法： <code>LRANGE key start stop</code></p>
<p>-1是倒数第一个 依次类推</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange gocybee 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;2&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h5><p>语法：<code>lpop key [count]</code></p>
<p>移除列表key的表头元素，出队列 counts是出队次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush gocybee 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h5><p>语法：<code>RPOP key [count]</code></p>
<p>移除列表key的尾元素，出队列 counts是出队次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange gocybee 0 -1</span><br><span class="line">1) &quot;twh&quot;</span><br><span class="line">2) &quot;tr&quot;</span><br><span class="line">3) &quot;lmj&quot;</span><br><span class="line">4) &quot;000&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP gocybee 1</span><br><span class="line">1) &quot;000&quot;</span><br></pre></td></tr></table></figure>

<h5 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h5><p>语法： <code>lset key index element</code></p>
<p>通过索引设置列表元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange gocybee 0 -1</span><br><span class="line">1) &quot;twh&quot;</span><br><span class="line">2) &quot;lmj&quot;</span><br><span class="line">3) &quot;wx&quot;</span><br><span class="line">4) &quot;hhz&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset gocybee 1 tr</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange gocybee 0 -1</span><br><span class="line">1) &quot;twh&quot;</span><br><span class="line">2) &quot;tr&quot;</span><br><span class="line">3) &quot;wx&quot;</span><br><span class="line">4) &quot;hhz&quot;</span><br></pre></td></tr></table></figure>

<h5 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h5><p>语法：<code>llen key</code></p>
<p>获取列表长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen gocybee</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h5 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h5><p>语法： <code>blpop key [key ...] timeout</code></p>
<p>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</p>
<p>timeout （s）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush gocybee &#x27;hello gocybee&#x27;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; blpop gocybee 50</span><br><span class="line">1) &quot;gocybee&quot;</span><br><span class="line">2) &quot;hello gocybee&quot;</span><br><span class="line">(22.08s)</span><br></pre></td></tr></table></figure>

<p>其他命令 help @list 解决</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p>Set 类型和 List 类型的区别如下：</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素；</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li>
</ul>
<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h4 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h5><p>语法：<code>SADD key member [member ...]</code></p>
<p>往集合key中存入元素，元素存在则忽略，若key不存在则新建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD gocybee 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD gocybee 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h5 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h5><p>语法：<code>SREM key member [member ...]</code></p>
<p>从集合key中删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SREM gocybee 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SREM gocybee 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h5 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h5><p>语法：<code>SMEMBERS key</code></p>
<p>查看所有的members</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers gocybee</span><br><span class="line">1) &quot;wx&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h5><p>语法：<code>SCARD key</code></p>
<p>查看元素个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCARD gocybee</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h5><p>语法：<code>SISMEMBER key member</code></p>
<p>判断元素是否是在集合中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISmember gocybee wx</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h5><p>语法： <code>SRANDMEMBER key [count]</code></p>
<p>从集合key中随机选出count个元素，元素不从key中删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Srandmember gocybee 3</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br><span class="line">3) &quot;mj&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h5><p>语法：  <code>SPOP key [count]</code></p>
<p>从集合key中随机选出count个元素，元素从key中删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Smembers gocybee</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br><span class="line">3) &quot;wx&quot;</span><br><span class="line">127.0.0.1:6379&gt; SPOP gocybee 1</span><br><span class="line">1) &quot;wx&quot;</span><br><span class="line">127.0.0.1:6379&gt; Smembers gocybee</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h5><p>语法： <code>SINTER key [key ...]</code></p>
<p>交集运算返回两个set的交集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Smembers gocybee</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br><span class="line">3) &quot;mj&quot;</span><br><span class="line">127.0.0.1:6379&gt; Smembers lanshan</span><br><span class="line">1) &quot;lpc&quot;</span><br><span class="line">2) &quot;yxh&quot;</span><br><span class="line">3) &quot;hhz&quot;</span><br><span class="line">4) &quot;mj&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER  gocybee lanshan</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br><span class="line">3) &quot;mj&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h5><p>语法： <code>SINTERSTORE destination key [key ...]</code></p>
<p>将交集结果存入新集合destination中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SINTERSTORE common gocybee lanshan</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers common</span><br><span class="line">1) &quot;yxh&quot;</span><br><span class="line">2) &quot;hhz&quot;</span><br><span class="line">3) &quot;mj&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h5><p>语法： <code>SUNION gocybee lanshan</code></p>
<p>并集运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUNION gocybee lanshan</span><br><span class="line">1) &quot;hhz&quot;</span><br><span class="line">2) &quot;mj&quot;</span><br><span class="line">3) &quot;lpc&quot;</span><br><span class="line">4) &quot;yxh&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h5><p>语法： <code>SUNIONSTORE destination key [key ...]</code></p>
<p>将并集结果存入新集合destination中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUNIONSTORE union gocybee lanshan</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; Smembers union</span><br><span class="line">1) &quot;mj&quot;</span><br><span class="line">2) &quot;lpc&quot;</span><br><span class="line">3) &quot;yxh&quot;</span><br><span class="line">4) &quot;hhz&quot;</span><br></pre></td></tr></table></figure>

<h5 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h5><p>差集运算 <code>SDIFF key [key ...]</code></p>
<h5 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a>SDIFFSTORE</h5><p>将差集结果存入新集合destination中 <code>SDIFFSTORE destination key [key ...]</code></p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h5 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h5><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCARD article:1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCARD article:1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h5 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h5><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<p><code>uid:1</code> 用户关注频道号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注 频道号id 为 7、8、9、10、11。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p>我们可以查看 <code>uid:1</code> 和 <code>uid:2</code> 共同关注的频道</p>
<p>可以向<code>uid:2</code>推荐 <code>uid:1</code> 的频道等等…</p>
<h5 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h5><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱</p>
<p>再利用 <code>SRANDRM</code> 或者是 <code>SPOP</code></p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<h5 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h5><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h4 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h5><p>语法 ：<code>ZADD key score member [[score member]...]</code></p>
<p>往有序集合key中加入带分值元素 ,core必须是浮点数或者整型，添加成功后返回被成功添加的新成员的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD movie 1 zl 2 lldq</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h5 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h5><p>语法 ：<code>ZREM key member [member...]</code></p>
<p>往有序集合key中删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREM movie zl</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h5><p>语法： <code>ZSCORE key member</code></p>
<p>返回有序集合key中元素member的分值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE movie lldq</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h5><p>语法： <code>ZCARD key</code></p>
<p>返回有序集合个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZCARD movie</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h5><p><code>ZINCRBY key increment member</code></p>
<p>为有序集合key中元素member的分值加上increment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY movie 3 lldq</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h5><p><code>ZRANGE key start stop [WITHSCORES]</code></p>
<p>正序获取有序集合key从start下标到stop下标的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE movie 0 -1</span><br><span class="line">1) &quot;zl&quot;</span><br><span class="line">2) &quot;lldq&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h5><p><code>ZREVRANGE key start stop [WITHSCORES]</code></p>
<p>倒序获取有序集合key从start下标到stop下标的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE movie  0 -1</span><br><span class="line">1) &quot;lldq&quot;</span><br><span class="line">2) &quot;zl&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZRANGENYSCORE"><a href="#ZRANGENYSCORE" class="headerlink" title="ZRANGENYSCORE"></a>ZRANGENYSCORE</h5><p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>
<p>返回有序集合中指定分数区间内的成员，分数由低到高排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE movie 0 100</span><br><span class="line">1) &quot;zl&quot;</span><br><span class="line">2) &quot;lldq&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h5><p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p>
<p>返回有序集合中指定分数区间内的成员，分数由高到低排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE movie 100 0</span><br><span class="line">1) &quot;lldq&quot;</span><br><span class="line">2) &quot;zl&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE movie lldq</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE movie zl</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h5><p><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>
<p>返回指定成员区间内的成员，按字典正序排列, 分数必须相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX movie - [zl</span><br><span class="line">1) &quot;zl&quot;</span><br><span class="line">2) &quot;lldq&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ZREVRANGEBYLEX"><a href="#ZREVRANGEBYLEX" class="headerlink" title="ZREVRANGEBYLEX"></a>ZREVRANGEBYLEX</h5><p><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></p>
<p>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</p>
<blockquote>
<p>**+ - ** 表示正无限 和负无限</p>
<p>( 不包含 [ 包含</p>
</blockquote>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p>
<h5 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h5><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<h5 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h5><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><code>help @bitmap</code></p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>1.签到统计 2.判断用户登陆态 3.连续签到用户总数 等等</p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中</p>
<h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p>
<p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>1.查找附加的人 车 物品</p>
<h1 id="GO使用redis"><a href="#GO使用redis" class="headerlink" title="GO使用redis"></a>GO使用redis</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/go-redis/redis/v8</span><br></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="普通连接模式"><a href="#普通连接模式" class="headerlink" title="普通连接模式"></a>普通连接模式</h4><p>go-redis 库中使用 redis.NewClient 函数连接 Redis 服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">	Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">	Password: <span class="string">&quot;&quot;</span>, <span class="comment">// 密码</span></span><br><span class="line">	DB:       <span class="number">0</span>,  <span class="comment">// 数据库</span></span><br><span class="line">	PoolSize: <span class="number">20</span>, <span class="comment">// 连接池大小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除此之外，还可以使用 redis.ParseURL 函数从表示数据源的字符串中解析得到 Redis 服务器的配置信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opt, err := redis.ParseURL(<span class="string">&quot;redis://&lt;user&gt;:&lt;pass&gt;@localhost:6379/&lt;db&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rdb := redis.NewClient(opt)</span><br></pre></td></tr></table></figure>

<h4 id="TLS连接模式"><a href="#TLS连接模式" class="headerlink" title="TLS连接模式"></a>TLS连接模式</h4><p>如果使用的是 TLS 连接方式，则需要使用 tls.Config 配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">	TLSConfig: &amp;tls.Config&#123;</span><br><span class="line">		MinVersion: tls.VersionTLS12,</span><br><span class="line">		<span class="comment">// Certificates: []tls.Certificate&#123;cert&#125;,</span></span><br><span class="line">    <span class="comment">// ServerName: &quot;your.domain.com&quot;,</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Sentinel模式"><a href="#Redis-Sentinel模式" class="headerlink" title="Redis Sentinel模式"></a>Redis Sentinel模式</h4><p>使用下面的命令连接到由 Redis Sentinel 管理的 Redis 服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewFailoverClient(&amp;redis.FailoverOptions&#123;</span><br><span class="line">    MasterName:    <span class="string">&quot;master-name&quot;</span>,</span><br><span class="line">    SentinelAddrs: []<span class="type">string</span>&#123;<span class="string">&quot;:9126&quot;</span>, <span class="string">&quot;:9127&quot;</span>, <span class="string">&quot;:9128&quot;</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster模式"><a href="#Redis-Cluster模式" class="headerlink" title="Redis Cluster模式"></a>Redis Cluster模式</h4><p>使用下面的命令连接到 Redis Cluster，go-redis 支持按延迟或随机路由命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewClusterClient(&amp;redis.ClusterOptions&#123;</span><br><span class="line">    Addrs: []<span class="type">string</span>&#123;<span class="string">&quot;:7000&quot;</span>, <span class="string">&quot;:7001&quot;</span>, <span class="string">&quot;:7002&quot;</span>, <span class="string">&quot;:7003&quot;</span>, <span class="string">&quot;:7004&quot;</span>, <span class="string">&quot;:7005&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若要根据延迟或随机路由命令，请启用以下命令之一</span></span><br><span class="line">    <span class="comment">// RouteByLatency: true,</span></span><br><span class="line">    <span class="comment">// RouteRandomly: true,</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>从<code>Redis</code>获取到的值是空接口类型，要是其转化为string类型可通过fmt.Sprintf函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str:=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> val.([]<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	str = fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, v)</span><br><span class="line">	fmt.Println(k, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/07/Redis%E7%AC%94%E8%AE%B0/" data-id="clyfhaq7600041487guc769lh" data-title="Redis笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/09/MySQL%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-05-09T03:19:35.000Z" itemprop="datePublished">2023-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/09/MySQL%E7%AC%94%E8%AE%B0/">MySQL笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h2><ul>
<li><p>连接数据库语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>padmin;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据库列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段 字段类型,字段 字段类型);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>(添加字段)<span class="operator">/</span>modify(修改字段类型)<span class="operator">/</span>change(修改字段名称及类型)<span class="operator">/</span><span class="keyword">drop</span>(删除字段)<span class="operator">/</span>rename <span class="keyword">to</span>(修改表名)...</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h2><ul>
<li><p>添加数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...)(值<span class="number">1</span>,值<span class="number">2</span>,...)...</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>，字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span> <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DQL操作"><a href="#DQL操作" class="headerlink" title="DQL操作"></a>DQL操作</h2><ul>
<li>查找数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段列表 <span class="keyword">having</span> 分组后条件列表 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段列表(升序<span class="keyword">ASC</span> 降序<span class="keyword">DESC</span>) limit 分页参数</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li>非空约束  not null</li>
<li>唯一约束  unique</li>
<li>主键约束  primary key (自增: auto_increment)</li>
<li>默认约束  default</li>
<li>检查约束  check</li>
<li>外键约束  foreign key</li>
</ul>
<p>其中外键约束所含约束</p>
<ul>
<li>no action(等同于restrict) 删除更新父表对应记录时，检查是否有外键，若有则不能动</li>
<li>cascade 同步更新删除</li>
<li>set null  删除父表对应记录时将对应外键赋值为null</li>
<li>set default 父表有变更时，子表将外键赋默认值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段) <span class="keyword">references</span> 主表名(主表字段名) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul>
<li><p>隐式内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 条件...</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件</span><br></pre></td></tr></table></figure></li>
</ul>
<p>区别：显式比隐式更加高效且不易混淆</p>
<ul>
<li><p>外连接（包含左&#x2F;右表及交集部分的数据）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>自连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件</span><br></pre></td></tr></table></figure>
<p>ps：自连接时把一个表想成两个表更好理解</p>
</li>
<li><p>联合查询(把多次查询结果合在一起)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>] <span class="comment">---不加all时会把多次查询相同的数据只留一次</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>事务特性</li>
</ul>
<ol>
<li>原子性(Atomicity)</li>
<li>一致性(Consistency)</li>
<li>隔离性(Isolation)</li>
<li>持久性(Durability)</li>
</ol>
<ul>
<li>事务操作<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction <span class="comment">---开启事务</span></span><br><span class="line"><span class="keyword">commit</span> <span class="comment">---提交事务</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="comment">---回滚事务</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="GO使用MySQL"><a href="#GO使用MySQL" class="headerlink" title="GO使用MySQL"></a>GO使用MySQL</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>
<h3 id="使用MySQL驱动"><a href="#使用MySQL驱动" class="headerlink" title="使用MySQL驱动"></a>使用MySQL驱动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般至少包括数据库文件名和其它连接必要的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">	dsn := <span class="string">&quot;user:password@tcp(127.0.0.1:3306)/dbname&quot;</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()  <span class="comment">// 注意这行代码要写在上面err判断的下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h3><p>Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。</p>
<p>返回的DB对象可以安全地被多个goroutine并发使用，并且维护其自己的空闲连接池。因此，Open函数应该仅被调用一次，很少需要关闭这个DB对象。</p>
<p>接下来，我们定义一个全局变量<code>db</code>，用来保存数据库连接对象。将上面的示例代码拆分出一个独立的<code>initDB</code>函数，只需要在程序启动时调用一次该函数完成全局变量db的初始化，其他函数中就可以直接使用全局变量<code>db</code>了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// DSN:Data Source Name</span></span><br><span class="line">	dsn := <span class="string">&quot;user:password@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">	<span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line">	<span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">	db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">	err = db.Ping()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>sql.DB</code>是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个goroutine同时使用。</p>
<h3 id="SetMaxOpenConns"><a href="#SetMaxOpenConns" class="headerlink" title="SetMaxOpenConns"></a>SetMaxOpenConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxOpenConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><code>SetMaxOpenConns</code>设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n&lt;&#x3D;0，不会限制最大开启连接数，默认为0（无限制）。</p>
<h3 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a>SetMaxIdleConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxIdleConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>SetMaxIdleConns设置连接池中的最大闲置连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n&lt;&#x3D;0，不会保留闲置连接。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><code>engine = 存储引擎</code></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>![[Pasted image 20230804190048.png]]</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>将数据存储与索引放到了一块，索引结构的叶子节点保存了整行的数据（特点是必须存在且只能由有一个）</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>将数据索引分开存储，索引结构的叶子节点关联的是对应的主键（可以存在多个，不是聚集索引的都是二级索引√）<br>二级索引需要扫描两个索引，进行回表查询，更加耗时，能通过聚集索引就聚集索引查</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>![[Pasted image 20230806204118.png]]<br>![[Pasted image 20230806204140.png]]</p>
<p>当字段类型为字符串（varchar,text…）时，需要索引很长的字符串，这会让索引变得很大，查询时大量浪费磁盘IO，影响查询效率，此时可以将字符串部分前缀建立索引，这样可以大大节约索引空间，提高索引效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名 (字段名(截取前缀长度))</span><br></pre></td></tr></table></figure>

<p>前缀长度可通过索引选择性决定，而选择性时指不重复的索引值（基数）和数据表的记录总数的比值。选择性越高，效率越高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 字段名)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(字段名,起始,结束))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名</span><br><span class="line"><span class="comment">--可用以上语句求得选择性</span></span><br><span class="line">eg：</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">10</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> users</span><br></pre></td></tr></table></figure>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ul>
<li><p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span><span class="operator">|</span>fulltext] index index_name <span class="keyword">on</span> table_name(table_col_name,...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引使用情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span>语句 </span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL提示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use index     <span class="comment">--建议使用</span></span><br><span class="line">ignore index  <span class="comment">--不要使用</span></span><br><span class="line">force index   <span class="comment">--强制使用</span></span><br><span class="line"><span class="comment">--在select语句后接提示语句可达到优化操作的目的</span></span><br><span class="line">eg：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users use<span class="operator">/</span>ignore<span class="operator">/</span>force index(索引名) <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h4><ul>
<li><p>使用联合索引查询时，不能跳过第一个索引查询，否则失效</p>
</li>
<li><p>使用联合索引查询时，出现范围查询（&gt;,&lt;）,范围查询右侧的列索引失效，若要范围查询尽量通过大于等于（&gt;&#x3D;）,小于等于（&lt;&#x3D;）,这样右侧列索引就不会失效</p>
</li>
<li><p>不能在索引列上运算，否则索引失效</p>
</li>
<li><p>字符串类型数据不加单引号，索引失效</p>
</li>
<li><p>尾部模糊搜索，索引失效，头部模糊搜索，索引有效</p>
</li>
<li><p>用or分开的条件，若or前条件有索引，后面没有，则索引失效</p>
</li>
<li><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，应该用联合索引，避免回表查询</p>
</li>
<li><p>控制索引数量，索引越多维护成本越高，会影响增删改</p>
</li>
<li><p>如果索引列不能存NULL，需要在建表时用NOT NULL约束</p>
</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>一次性插入大量数据，使用insert语句插入性能较低，可用load指令进行插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#客户端连接服务端时，加上参数 <span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u -root -p</span></span><br><span class="line"></span><br><span class="line">#设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#执行load指令将准备好的数据加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;文件路径&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> 表名 fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> <span class="comment">--逗号间隔列 换行间隔行 可自定义</span></span><br></pre></td></tr></table></figure>

<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>![[Pasted image 20230807214404.png]]</p>
<h4 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h4><ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，使用auto_increment</li>
<li>尽量不要用UUID做主键或其他自然主键，如身份证号码</li>
<li>业务操作时，避免对主键的修改</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/09/MySQL%E7%AC%94%E8%AE%B0/" data-id="clyfhaq4w00031487hjlmcry3" data-title="MySQL笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/10/%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/">在数据库中存入自定义类型</a>
          </li>
        
          <li>
            <a href="/2024/07/23/Go%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BA%93-base64Chaptcha%E7%9A%84%E4%BD%BF%E7%94%A8/">Go图形验证码库-base64Chaptcha的使用</a>
          </li>
        
          <li>
            <a href="/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">再遇跨域问题</a>
          </li>
        
          <li>
            <a href="/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/">正则表达式笔记</a>
          </li>
        
          <li>
            <a href="/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/">go算法小抄</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Keiichi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>