<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Keiichi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="My Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Keiichi&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Keiichi&#39;s blog">
<meta property="og:description" content="My Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keiichi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Keiichi's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keiichi&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-再遇跨域问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-07-16T05:54:13.000Z" itemprop="datePublished">2024-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">再遇跨域问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p>在最开始遇到跨域问题，只是有点懵懂的认知，并未深入了解，在项目中也是直接Ctrl C  Ctrl V解决跨域问题的代码就草草了事。又因为在后面的项目中，每次复制粘贴了之前的代码都能解决问题，我也没有过多考虑了。</p>
<p>这几天偶然又遇到了跨域问题，想尝试以下自己写，查询了不少相关资料，于是就有了这篇笔记</p>
<h2 id="什么是跨域问题"><a href="#什么是跨域问题" class="headerlink" title="什么是跨域问题"></a>什么是跨域问题</h2><p><strong>跨域问题</strong>指的是在Web应用程序中，由于<strong>同源策略的限制</strong>，导致浏览器无法发送跨域请求，也无法获取跨域响应的问题。同源策略要求Web应用程序只能访问与当前页面具有相同协议、主机名和端口号的资源 <del>网上已经讲的很详细了，直接copy过来</del></p>
<p>也就是说，只要你无法满足同协议，同主机，同端口这三大要求，你就不能发送请求 </p>
<h2 id="为什么不能发送跨域请求"><a href="#为什么不能发送跨域请求" class="headerlink" title="为什么不能发送跨域请求"></a>为什么不能发送跨域请求</h2><p><strong>罪魁祸首</strong>就是浏览器的<strong>同源策略</strong></p>
<h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<strong>源</strong>的文档或者它加载的脚本如何能与另一个源的资源进行交互。   <em>PS：源&#x3D;协议+主机+端口  当两个源之间三者相同，则我们称这两个源是同源</em></p>
<p>浏览器会限制不同源之间的交流，可以阻挡一些恶意文件和恶意请求 ，起到一定的防御效果<br>比如说，你在公司上班时不小心点入了一个小网站，在你点入的同时，这个网站启动了他的JS脚本，这个脚本可以通过你的主机访问你已经登录的某些网页（QQ邮箱，淘宝等）或者是公司内网，然后窃取你的数据转发出去，在同源策略的保护下，这个操作就行不通了，因为跨域了。</p>
<p>*为什么可以访问公司内网？公司内网不是公开的IP，无法从公网直接访问，但是你的电脑可以访问内网，所以可以用你电脑当跳板来访问内网。 *</p>
<h2 id="演示跨域过程"><a href="#演示跨域过程" class="headerlink" title="演示跨域过程"></a>演示跨域过程</h2><p><em>Talk is cheap, show me you code</em><br>下面我们来运行一个后端程序放在端口<code>:8021</code><br>然后写一个html文件来向它发起请求</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;query&quot;</span>&gt;</span>发起请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#query&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(  </span></span><br><span class="line"><span class="language-javascript">            &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>:<span class="string">&quot;http://localhost:8021/v1/user/list&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">beforeSend</span>: <span class="keyword">function</span> (<span class="params">request</span>)&#123;  </span></span><br><span class="line"><span class="language-javascript">                    request.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;x-token&quot;</span>,<span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MywiTmlja25hbWUiOiJ1c2VyMiIsIkF1dGhvcml0eUlkIjoxLCJleHAiOjE3MjM2OTUzNjUsImlzcyI6Im1lIiwibmJmIjoxNzIxMTAzMzY1fQ.dnzeX6tiSkj2XHfZ9ZAcGmUJSRpStPoVnRZe7h3TR1E&quot;</span>)  </span></span><br><span class="line"><span class="language-javascript">                &#125;,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">result</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>)  </span></span><br><span class="line"><span class="language-javascript">                    $(<span class="string">&quot;#content&quot;</span>).<span class="title function_">text</span>(result.<span class="property">data</span>)  </span></span><br><span class="line"><span class="language-javascript">                &#125;,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params">data</span>)&#123;  </span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&quot;failed&quot;</span>)  </span></span><br><span class="line"><span class="language-javascript">                &#125;  </span></span><br><span class="line"><span class="language-javascript">            &#125;  </span></span><br><span class="line"><span class="language-javascript">        )  </span></span><br><span class="line"><span class="language-javascript">    &#125;)  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击<code>发起请求</code>后 F12发现给出的状态码是<code>404</code>,请求方法是 <code>Options</code></p>
<p>![[Pasted image 20240716145947.png]]</p>
<p><em>为什么?</em><br>因为在浏览器进行复杂请求时，它会先向目标地址发送一次options预检请求，检查当前请求是否符合服务端的cors配置，如果符合，则再发出真正的请求。如果不符合，则直接返回跨域报错。<br>因为我们后端没有配置 cors，所以预检失败，跨域请求也就失败了</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>上面我们提到时因为不满足服务端的cors配置，那么我们只需要在后端配置cors即可，这里我们使用gin的中间件举例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CORS</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">		ctx.Writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">		ctx.Writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">		ctx.Writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With, token, x-token&quot;</span>)</span><br><span class="line">		ctx.Writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, OPTIONS, GET, PUT, DELETE&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ctx.Request.Method == <span class="string">&quot;OPTIONS&quot;</span> &#123;</span><br><span class="line">			ctx.AbortWithStatus(<span class="number">204</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		ctx.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分别讲解一下各个参数含义 </p>
<ul>
<li><code>Access-Control-Allow-Origin</code>: 被允许发送请求的源，<code>*</code>代表都可以  </li>
<li><code>Access-Control-Allow-Credentials</code>: 是否允许客户端发送Credentials(凭证)</li>
<li><code>Access-Control-Allow-Headers</code>:被允许携带的请求头</li>
<li><code>Access-Control-Allow-Methods</code>:被允许的请求方式</li>
</ul>
<p>设置完成后，再单独处理一下预检请求options，就可以完美解决跨域问题了 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" data-id="clyo347o50000x087d823eawg" data-title="再遇跨域问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-正则表达式笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-07-06T04:02:21.000Z" itemprop="datePublished">2024-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/">正则表达式笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>+</code>可以匹配前面字符的一个或者多个，例：<code>abb+c</code> 可以匹配<code>abbbc</code>,<code>abbbbbbc</code></li>
<li><code>*</code>可以表示前面字符不出现或者出现一个或多个，例：<code>abb*c</code> 可以匹配 <code>abc</code>,<code>abbc</code>,<code>abbbbbc</code></li>
<li><code>?</code>可以表示前面字符出现一次或不出现，例：<code>colou?r</code>可以匹配<code>color</code>和<code>colour</code></li>
<li><code>[ ]</code>可以匹配<code>[...]</code>所有的字符，例：<code>[abc]</code>能匹配<code>xxxxaxxxbxxc</code>中的<code>a</code>,<code>b</code>,<code>c</code>,后续可进行替换等操作</li>
<li><code>[^]</code>可以匹配除了<code>[...]</code>中所有的字符，例：<code>[^abc]</code>能匹配<code>xxxxaxxxbxxc</code>中所有的<code>x</code>后续可进行替换等操作</li>
<li><code>[A-Z]</code>表示匹配所有的大写字母 </li>
<li><code>[a-z]</code>表示匹配所有的小写字母 </li>
<li><code>.</code>匹配换行符之外的所有字符，等价于<code>[^\r\n]</code></li>
<li><code>[\s]</code>匹配所有的空白符（不包括换行符）</li>
<li><code>[\S]</code>匹配所有的非空白符 （不包括换行符）</li>
<li><code>\w</code>匹配所有的字母数字下划线，等价于<code>[A-Za-z0-9_]</code></li>
<li><code>\d</code>匹配所有的阿拉伯数字，等价于<code>[0-9]</code></li>
<li><code>^1([38][0-9]|14[579]|5[^4]|16[6]|7[1-35-8]|9[189])\d&#123;8&#125;$</code>（手机号正则表达式）</li>
</ul>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则<code>$</code> 也匹配 <code>&#39;\n&#39;</code> 或 <code>&#39;\r&#39;</code>。要匹配 <code>$</code> 字符本身，请使用 <code>\$</code></td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和<code>\)</code></td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用<code> \*</code></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用 <code>\+</code></td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符<code>\n</code> 之外的任何单字符。要匹配 <code>.</code> ，请使用 <code>\.</code></td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配<code>?</code> 字符，请使用<code>\?</code></td>
</tr>
<tr>
<td>|</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>&#39;n&#39;</code> 匹配字符 <code>&#39;n&#39;</code>。<code>&#39;\n&#39;</code> 匹配换行符。序列 <code>&#39;\\&#39;</code> 匹配 <code>&quot;\&quot;</code>，而 <code>&#39;\(&#39;</code> 则匹配 <code>&quot;(&quot;</code></td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code></td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。要匹配 <code>&#123;</code>，请使用 <code>\&#123;</code></td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择。要匹配 <code>|</code>，请使用 <code>\\</code></td>
</tr>
</tbody></table>
<h2 id="限定符号"><a href="#限定符号" class="headerlink" title="限定符号"></a>限定符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 <strong>“z”</strong> 以及 **”zoo”*<em>。</em> 等价于 {0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，zo+ 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 **”z”**。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 <strong>“do”</strong> 、 **”does”**、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 和 **”does”**。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，o{2} 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。o{1,} 等价于 o+。o{0,} 则等价于 o*。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>ignore - 不区分大小写</td>
<td>将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td>
</tr>
<tr>
<td>g</td>
<td>global - 全局匹配</td>
<td>查找所有的匹配项。</td>
</tr>
<tr>
<td>m</td>
<td>multi line - 多行匹配</td>
<td>使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td>s</td>
<td>特殊字符圆点 . 中包含换行符 \n</td>
<td>默认情况下的圆点 . 是匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/" data-id="clymkywgk000058873v3le1a1" data-title="正则表达式笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-go算法小抄" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T10:09:22.000Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/">go算法小抄</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="103-二叉树的锯齿形层序遍历-力扣（LeetCode）"><a href="#103-二叉树的锯齿形层序遍历-力扣（LeetCode）" class="headerlink" title="103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）</a></h1><h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><p>在go中都可以用切片来简易实现(只进不出可读那种，有较大限制)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">栈</span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">入栈</span><br><span class="line">stack=<span class="built_in">append</span>(stack,x)</span><br><span class="line"></span><br><span class="line">出栈（实际并没有出栈，只是按着栈的性质读取）</span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(stack);i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">	temp:=stack[i]</span><br><span class="line">	...</span><br><span class="line">	读出来进行相应操作 </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队列</span><br><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">入队列</span><br><span class="line">queue=<span class="built_in">append</span>(queue,x)</span><br><span class="line"></span><br><span class="line">出队列</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(queue);i++&#123;</span><br><span class="line">	temp:=queue[i]</span><br><span class="line">	...</span><br><span class="line">	读出来进行相应操作 </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS二叉树层数表示"><a href="#BFS二叉树层数表示" class="headerlink" title="BFS二叉树层数表示"></a>BFS二叉树层数表示</h2><p>可以用上文的队列实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret:=[][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    queue:=[]*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="comment">//level就是层，巧妙实现了层数表示</span></span><br><span class="line">    <span class="keyword">for</span> level:=<span class="number">0</span>;<span class="built_in">len</span>(queue)&gt;<span class="number">0</span>;level++&#123;</span><br><span class="line">        val:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        q:=queue</span><br><span class="line">        <span class="comment">//这里清空了queue，方便下一层塞入queue</span></span><br><span class="line">        queue=<span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(q);i++&#123;</span><br><span class="line">            val=<span class="built_in">append</span>(val,q[i].Val)</span><br><span class="line">            <span class="keyword">if</span> q[i].Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">                queue=<span class="built_in">append</span>(queue,q[i].Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> q[i].Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">                queue=<span class="built_in">append</span>(queue,q[i].Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> level%<span class="number">2</span>!=<span class="number">0</span>&#123;</span><br><span class="line">            temp:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i:=<span class="built_in">len</span>(val)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">                temp=<span class="built_in">append</span>(temp,val[i])</span><br><span class="line">            &#125;</span><br><span class="line">            ret=<span class="built_in">append</span>(ret,temp)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret=<span class="built_in">append</span>(ret,val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="236-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#236-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="236. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h1><h2 id="二叉树节点的向上寻找"><a href="#二叉树节点的向上寻找" class="headerlink" title="二叉树节点的向上寻找"></a>二叉树节点的向上寻找</h2><p>找公共祖先的时候，需要往上找，但是一直没想到怎么向上移动，这里是个小技巧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node!=<span class="literal">nil</span>&#123;</span><br><span class="line">	node=parent[node.val]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leecode中编译器的区别"><a href="#leecode中编译器的区别" class="headerlink" title="leecode中编译器的区别"></a>leecode中编译器的区别</h2><p>在使用leecode刷题的时候发现，一样的代码放在本地编译器能跑，提交却总有莫名其妙的地方报错，按如下情况修改即可</p>
<ul>
<li>想使用c++那样的全局变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在使用leecode时，写的函数读入全局变量会莫名其妙出错导致TLE或者MLE</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">map</span>[<span class="type">int</span>][<span class="type">int</span>]&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>() <span class="comment">//莫名其妙报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按如下形式修改即可</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a=<span class="keyword">map</span>[<span class="type">int</span>][<span class="type">int</span>]&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">print</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		a[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>()<span class="comment">//这样就没问题了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（LeetCode）</a>中也出现了这样的错误，修改之后就能成功运行了<br>ps:可苦死我了，还一直以为是我的问题，跟这道题耗了一个下午<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vis [<span class="number">301</span>][<span class="number">301</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> dir = [<span class="number">4</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> Mx, My <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> count =<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>,grid [][]<span class="type">byte</span>)</span></span></span><br><span class="line">    Mx = <span class="built_in">len</span>(grid)</span><br><span class="line">    My = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dfs=<span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>, grid [][]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">        vis[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">            nx := x + dir[i][<span class="number">0</span>]</span><br><span class="line">            ny := y + dir[i][<span class="number">1</span>]</span><br><span class="line">            <span class="comment">//判断是否出界</span></span><br><span class="line">            <span class="keyword">if</span> nx &gt;= Mx || nx &lt; <span class="number">0</span> || ny &gt;= My || ny &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没出就看是不是符合条件的</span></span><br><span class="line">            <span class="keyword">if</span> grid[nx][ny] == <span class="string">&#x27;0&#x27;</span> || vis[nx][ny] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">//不符合就看下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nx, ny, grid)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> Mx==<span class="number">1</span>&amp;&amp;My==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Mx; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; My; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; vis[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                dfs(i, j, grid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/" data-id="clyfhaq770006148783auhjuq" data-title="go算法小抄" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-TCPIP协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2024-06-25T03:00:10.000Z" itemprop="datePublished">2024-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/">TCPIP协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP协议是传输控制协议，即Transmission Control Protocol</p>
<p>基于TCP协议的有<code>HTTP（互联网）</code>、<code>SMTP（邮件）</code>、<code>POP3（邮件）</code>、<code>FTP（文件）</code>、<code>Talent（远程终端接入）</code></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>面向字节流</li>
<li>面向连接</li>
<li>全双工通信（双方可互相发送和接受信息）</li>
<li>可靠（三次握手四次挥手）</li>
<li>效率慢（需要三次握手建立连接）</li>
</ul>
<h2 id="报文段格式"><a href="#报文段格式" class="headerlink" title="报文段格式"></a>报文段格式</h2><p>TCP协议虽然面向字节流，但是传输的数据单元还是报文<img src="/a.png"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>本报文段所发送数据的第一个字节的序号</td>
<td>4字节</td>
</tr>
<tr>
<td>ACK(确认号)</td>
<td>期望收到对方下一个报文段的第一个数据字节的序号</td>
<td>若ACK&#x3D;N，则表明N-1前的数据正确收到</td>
</tr>
<tr>
<td>SYN(同步位)</td>
<td>连接建立时用同步序号</td>
<td>若SYN&#x3D;1,ACK&#x3D;0表示连接请求报文段<br>若SYN&#x3D;1,ACK&#x3D;1表示连接请求响应报文段</td>
</tr>
<tr>
<td>FIN(终止控制位)</td>
<td>释放连接</td>
<td>FIN&#x3D;1表示发送方数据发送完毕，请求释放连接</td>
</tr>
</tbody></table>
<h2 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/b.png"></p>
<ol>
<li>第一次：<code>客户端</code>向<code>服务器</code>发送一个请求连接的报文段（SYN&#x3D;1和一个随机的起始序号seq&#x3D;x）;此时报文段没有携带数据，<code>客户端</code>进入<code>同步已发送</code>状态<br><del>【客户端：兄弟给你发了个x，你看一下】</del></li>
<li>第二次：<code>服务器</code>接受到了<code>客户端</code>发送的报文后，向<code>客户端</code>发送响应报文（SYN&#x3D;1，ACK&#x3D;1）;此时<code>客户端</code><strong>为该TCP连接分配了TCP缓存和变量</strong><br><del>【服务器：收到兄弟，你发的是x吧？我给你x加个1再发给你，然后再随便发你个y，你注意查收】</del></li>
<li>第三次：<code>客户端</code>收到<code>服务器</code>发来的响应报文段后，再向<code>服务器</code>发送连接确认报文段（ACK&#x3D;1）;此时<code>服务端</code><strong>为该TCP连接分配TCP缓存和变量</strong><br><del>【客户端：奈斯兄嘚，知道你收到x还给我加1了，我也收到你发的y了，我也加1给你发过去】</del></li>
<li>已建立一条 TCP 连接，若在此期间未收到对方回复，会重新发送报文</li>
</ol>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><ul>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。<br>同时也可以防止服务器接收<strong>早已失效的请求</strong>，一直等待客户端的响应，形成死锁，造成资源浪费</p>
<h3 id="为什么不能二次握手"><a href="#为什么不能二次握手" class="headerlink" title="为什么不能二次握手"></a>为什么不能二次握手</h3><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，这是正常情况<br>如果客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，但是发出的确认号和建立连接后的确认号对不上，就会导致客户端会忽略服务端发来的确认请求。但由于是两次握手确认连接，服务端认为已经连接上了，就可以发送数据，但是客户端仍会忽略，造成资源浪费</p>
<h3 id="三次握手可以携带数据吗"><a href="#三次握手可以携带数据吗" class="headerlink" title="三次握手可以携带数据吗"></a>三次握手可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p>
<h2 id="释放连接过程"><a href="#释放连接过程" class="headerlink" title="释放连接过程"></a>释放连接过程</h2><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/c.png"></p>
<ul>
<li>第一次：<code>客户端</code> 向<code>服务器</code>发送一个连接释放的报文段，并且<code>客户端</code>会停止再发送数据，等待<code>服务器</code>的确认</li>
<li>第二次：<code>服务器</code>收到连接释放报文后，向<code>客户端</code>发送连接释放确认报文段，至此，<code>客户端</code>–&gt;<code>服务器</code>的TCP连接已经断开了，处于半关闭状态</li>
<li>第三次 ：<code>服务器</code>如果已经没有要向<code>客户端</code>发送的数据，就会发送连接释放的报文段，<code>服务器</code>进入最终确认状态</li>
<li>第四次：<code>客户端</code>收到连接释放报文段后，就会向<code>服务器</code>发送连接释放确认的报文段，等待2msl之后<code>客户端</code>关闭，<code>服务器</code>收到之后就关闭。<code>服务器</code>关的比<code>客户端</code>早</li>
</ul>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>四次挥手是为了保证双方都能通知对方断开连接，也就是释放连接后，双方都不能接收或者发送消息给对方</p>
<p>第一次和第二次挥手，是<code>客户端</code>单方面宣布对<code>服务器</code>断开连接，此时<code>客户端</code>–&gt;<code>服务器</code>的连接断开，但是<code>服务器</code>–&gt;<code>客户端</code>的连接还未断开，TCP连接处于半关闭状态</p>
<p>第三次和第四次挥手，是<code>服务器</code>宣布对<code>客户端</code>断开连接，此时<code>服务器</code>–&gt;<code>客户端</code>的连接断开，第四次挥手后，双方才彻底断开连接</p>
<h3 id="为什么最后要等待2MSL的时间"><a href="#为什么最后要等待2MSL的时间" class="headerlink" title="为什么最后要等待2MSL的时间"></a>为什么最后要等待2MSL的时间</h3><p><code>MSL</code> &#x3D; 最长报文段寿命（<code>Maximum Segment Lifetime</code>）<br>等待2MSL可以保证客户端发送的最后1个连接释放确认报文 、能到达服务器，从而使得服务器能正常释放连接</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/" data-id="clxu1rpbv0000dc876vrqfb7m" data-title="TCPIP协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-一些想说的话" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/" class="article-date">
  <time class="dt-published" datetime="2024-06-23T07:13:15.000Z" itemprop="datePublished">2024-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/">一些想说的话</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><p>双非二本计算机专业就读，啥也不会</p>
<h2 id="开局"><a href="#开局" class="headerlink" title="开局"></a>开局</h2><p>我高中的目标就是计算机专业，想成为那种拿着键盘噼里啪啦一顿乱杀的超牛黑客（感觉大家都是这么认为的），但是事与愿违，我的高考成绩并不理想，进了目前学校的软件工程专业。到目前为止感觉也不是很坏，因为软件工程和计算机专业学的差不多，也能接触到编程。<br>但是学校无语的操作来了，刚入校就有一个特色班选拔，分别是英软和日软。我果断选择参加了英软的面试选拔，过了，结果莫名其妙被分到了日软，真服了。求助过辅导员，也是没什么用。最后想着是金子在哪都会发光（高中生莫名的自信，其实自己就是一坨），只有硬着头皮认了，进了日软班学习日语（进去后发现大部分哥们都是被莫名其妙坑进来的，心情顿时愉快了不少）。</p>
<h2 id="日语学习"><a href="#日语学习" class="headerlink" title="日语学习"></a>日语学习</h2><p>日语学起来不算很吃力，很好理解也很简单，就只是背的东西太多，变化的东西太多，不过我学的很认真，花了很多功夫去记忆，甚至还报了个校外的日语N2班。那段时间是很幸福的，能看见自己的日语水平正在以肉眼可见的速度增长着。感觉那时候应该是有N3的水平了吧（现在好久不碰都忘完了）</p>
<h2 id="转专业"><a href="#转专业" class="headerlink" title="转专业"></a>转专业</h2><p>我的均分和绩点是专业第二，所以有了转专业的机会，我考虑了很久要不要转去计算机专业，在深入了解后，我还是选择转去计算机专业。（真的考虑了好久好久，留下来继续学习可能有保研的机会，但是自己不知道能不能保持下去，而且自己的目标并不是读研，而是就业。转过去的话因为学习的课程学分差太多，需要留级一年，就会脱离目前熟悉的环境。我记得我当时连续两天都睡不着觉）</p>
<h2 id="工作室"><a href="#工作室" class="headerlink" title="工作室"></a>工作室</h2><p>大一的时候就加了红岩和蓝山工作室，接触了Go语言，了解了后端，也初步笃定了我以后的方向 <del>我要成为后端高手</del> 不过工作室的进度出奇快，每周一节课，一节课任务做一周，一节课的内容感觉是大学里C++课程一学期的进度（学校的进度真的很慢，一学期还在循环，连指针的影都见不到）</p>
<p>跟着学习了一年，不过因为我加入了其他的校级组织（勤工助学），每次工作室课程和组织活动的时间冲突，每周都要做一次二选一，时间也不太充裕 ，最后放弃了工作室那边的课程，花了大量时间组织活动上，现在很后悔。当时每组织一场活动，就能结识到许多人，而且也慢慢从内向变外向，当时是觉得，留在勤工更有用，成就感更大<del>而且每个月还有工资</del> 从现在看，实际上，这些组织活动的经历并不能给我带来什么<del>感觉是个人都能组织活动</del>，认识的那些“朋友”，也只是人生中的过客，除了加好友一开始聊的两句，之后再无联系。所以我很后悔，当初放下了后端学习</p>
<h2 id="留级"><a href="#留级" class="headerlink" title="留级"></a>留级</h2><p>我又变成了大一，心情是很复杂的，每次面对真正的大一都会很尴尬，不知道该用什么身份去交流，总会莫名其妙带入学长的身份说教，和目前同学的关系都不温不火，而且也不是住在一个寝室（转专业被发配到研究生寝室），交流的时间几乎为0</p>
<p>留级意味着有了更多充裕的时间，因为学过的课都不用再学了，所以我重新开始规划我的大一计划，先修了大二大三的部分课程，重新加入了蓝山工作室，留了勤工的负责人，充裕的时间被瞬间塞满（因为先修了很多门课，我上课时间其实和正常的大一大二学生差不多，甚至更多）</p>
<p>在上半学期，我是想重新牢固一下基础，于是就从最基础的算法开始学，也参加了一两个算法竞赛，都没拿到什么名次 （<del>我就是一坨</del> ），挫败感很强，不过好在通过了蓝山考核，又能留在蓝山了（其实是吃的之前老本，几乎没怎么跟着课程走）</p>
<h2 id="开始焦虑"><a href="#开始焦虑" class="headerlink" title="开始焦虑"></a>开始焦虑</h2><p>许多认识的人都去字节美团实习了，但自己感觉仍然没什么长进，也没有在后端有什么突破，只会简单的curd，我这一年到底在干嘛？急急急急急急急急急</p>
<h2 id="想要改变"><a href="#想要改变" class="headerlink" title="想要改变"></a>想要改变</h2><p>我真的需要改变，我没有沉下心来好好学某样东西，总是东学一点，西学一点，样样都拿不出手。我要好好学Go <del>我要成为后端高手</del> 不能再只喊着口号啥也不学了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/" data-id="clxsf5n7i00027c871hig6559" data-title="一些想说的话" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++算法笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/07/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-04-07T11:30:17.000Z" itemprop="datePublished">2024-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/07/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">C++算法笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>strlen()在cstring包里</li>
<li>保留小数位数，用setprecision()，在iomanip包里<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3.1415926</span></span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
<li>学习冒泡排序（将大的提到后面），选择排序（选出最小的提到前面），插入排序（类似理牌），希尔排序（分组插入排序，不断缩小间隔），快速排序（以最左侧为基准，小放左，大放右，左右双指针、递归）</li>
<li>栈（后进先出）、队列（先进先出，类似于GO中的channel）都是受到限制的线性表</li>
<li>取特定位数，只需要先除后取余<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> 个位=a/<span class="number">1</span>%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> 十位=a/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> 千位=a/<span class="number">1000</span>%<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>(index + 1) % MAX_SIZE</code> 可来计算队尾索引或队首索引。这样就能够实现队列的循环特性，确保队首和队尾索引在计算时正确地循环到数组的开头位置。</li>
<li>使用sort需要<code>#include&lt;algorithm&gt;</code>  ,关于其中cmp参数用法可见<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41575507/article/details/105936466">CSDN</a> </li>
<li>&#x3D;&#x3D;<code>!=</code>&#x3D;&#x3D;的判定时间比&#x3D;&#x3D;<code>==</code>&#x3D;&#x3D;的判定时间短，在大范围循环时多用&#x3D;&#x3D;<code>!=</code>&#x3D;&#x3D;可减少运行时间。</li>
<li>对于每一次循环都会进行操作的变量，把它放在<code>int main()</code>外面，作全局变量，可大幅减少运行时间。</li>
<li>辗转相除法求最大公约数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40763929/article/details/81629800">DFS入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/problem1825.html">穿越雷区（BFS和DFS练习）</a></li>
<li>DFS类的地图题可以用以下方法表示方向<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> way[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">      nx=x+way[i][<span class="number">0</span>];</span><br><span class="line">      ny=y+way[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//表示四个方向</span></span><br></pre></td></tr></table></figure></li>
<li>DFS伪代码模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(剪枝条件<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(剪枝条件<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(结束条件) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>()&#123;</span><br><span class="line">		vis[x][y]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>();<span class="comment">//往下探索</span></span><br><span class="line">		vis[x][y]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>BFS伪代码模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">queue&lt;<span class="type">int</span>&gt; arr</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	arr.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="type">int</span> y =arr.<span class="built_in">front</span>();</span><br><span class="line">	arr.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">while</span>(!arr.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		</span><br><span class="line">		对应操作</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>()&#123;</span><br><span class="line">			</span><br><span class="line">			对应操作</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在需要输入空格时，要用<code>gets</code>，不要用cin，否则读不进空格<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">gets</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另外必须引用的包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowerbound</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> target)</span></span>&#123; <span class="comment">//找到第一个大于等于target的值</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=target)&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upperbound</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> target)</span></span>&#123; <span class="comment">//找到第一个大于target的值 </span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=target)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;target)&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将十进制用2的幂次方表示<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">parse</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;x&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)temp.<span class="built_in">push</span>(i);</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Tarjan模板(找强连通分量)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    vis[now] = <span class="literal">true</span>; <span class="comment">// 标记为访问过</span></span><br><span class="line">    s.<span class="built_in">push</span>(now); <span class="comment">// 将该点压入栈中 </span></span><br><span class="line">    dfn[now] = low[now] = ++Time; <span class="comment">//记录时间戳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[now].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 搜索与该点联通的点 </span></span><br><span class="line">        <span class="type">int</span> To = graph[now][i]; <span class="comment">// 下一个将要访问的点 </span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[To]) &#123; <span class="comment">// 如果没有被搜过 </span></span><br><span class="line">            <span class="built_in">Tarjan</span>(To); <span class="comment">//开始搜索 </span></span><br><span class="line">            low[now] = <span class="built_in">min</span>(low[now], low[To]); <span class="comment">// 回溯更新 low值 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[To]) low[now] = <span class="built_in">min</span>(low[now], low[To]); <span class="comment">// 搜过了 直接更新 low </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[now] == low[now]) &#123; <span class="comment">// 找到一个强连通块的根 </span></span><br><span class="line">        col[now] = ++sum;  <span class="comment">// 染色 </span></span><br><span class="line">        vis[now] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//将搜索栈中该点以上的点弹出  他们都是在这个强联通块中 </span></span><br><span class="line">            <span class="type">int</span> x = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            col[x] = sum; <span class="comment">// 该强联通块染成第 sum种颜色 </span></span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (now == x) <span class="keyword">break</span>; <span class="comment">// 将根弹出后 结束循环 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最长公共子序列(LCS)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LCS[i][j] 表示第一个串的前i位，第二个串的前j位的LCS的长度</span><br><span class="line"><span class="comment">//动态规划 时间复杂度为O(n2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1[i]==p2[j])&#123;</span><br><span class="line">                LCS[i][j]=LCS[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                LCS[i][j]=<span class="built_in">max</span>(LCS[i<span class="number">-1</span>][j],LCS[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可使用滚动数组优化空间复杂度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1[i]==p2[j])&#123;</span><br><span class="line">            LCS[<span class="number">1</span>][j]=LCS[<span class="number">0</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LCS[<span class="number">1</span>][j]=<span class="built_in">max</span>(LCS[<span class="number">0</span>][j],LCS[<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(LCS[<span class="number">0</span>],LCS[<span class="number">1</span>],(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最长回文子序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=str.<span class="built_in">size</span>();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	dp[i][i]=<span class="number">0</span>;<span class="comment">//dp[i][j]是指从i到j的最长回文子序列长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;str.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i]==str[j])&#123;</span><br><span class="line">			dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组合数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>排列数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">A</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)&#123; </span><br><span class="line">		res *= n; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>卡特兰数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">C</span>(n,<span class="number">2</span>n)-<span class="built_in">C</span>(n<span class="number">-1</span>,<span class="number">2</span>n) 即 合法路径=总路径-非法路径</span><br></pre></td></tr></table></figure></li>
<li>素数筛<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(num==<span class="number">2</span>||num==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;num%<span class="number">6</span>!=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> temp=<span class="built_in">sqrt</span>(num);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i&lt;=temp;i+=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>||num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//欧拉筛</span></span><br><span class="line"><span class="type">bool</span> isprime[MAXN]; <span class="comment">// isprime[i]表示i是不是素数</span></span><br><span class="line"><span class="type">int</span> prime[MAXN]; <span class="comment">// 现在已经筛出的素数列表</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 上限，即筛出&lt;=n的素数</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 已经筛出的素数个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isprime, <span class="literal">true</span>, <span class="built_in">sizeof</span>(isprime)); <span class="comment">// 先全部标记为素数</span></span><br><span class="line">    isprime[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 1不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="comment">// i从2循环到n（外层循环）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i]) prime[++cnt] = i;</span><br><span class="line">        <span class="comment">// 如果i没有被前面的数筛掉，则i是素数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j)</span><br><span class="line">        <span class="comment">// 筛掉i的素数倍，即i的prime[j]倍</span></span><br><span class="line">        <span class="comment">// j循环枚举现在已经筛出的素数（内层循环）</span></span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 倍数标记为合数，也就是i用prime[j]把i * prime[j]筛掉了</span></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 最神奇的一句话，如果i整除prime[j]，退出循环</span></span><br><span class="line">            <span class="comment">// 这样可以保证线性的时间复杂度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>二叉树前中后遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据前序中序遍历 构造二叉树并 后序遍历输出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Hash;</span><br><span class="line">string pre,in;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    node* rt=<span class="keyword">new</span> node;</span><br><span class="line">    rt-&gt;val=pre[root];</span><br><span class="line">    <span class="type">int</span> m=Hash[root];</span><br><span class="line">    rt-&gt;left =<span class="built_in">build</span>(root+<span class="number">1</span>     ,l   ,m<span class="number">-1</span>);</span><br><span class="line">    rt-&gt;right=<span class="built_in">build</span>(root+<span class="number">1</span>+m-l ,m+<span class="number">1</span> ,r  );</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">buildTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node* TreeRoot=<span class="keyword">new</span> node;</span><br><span class="line">    TreeRoot=<span class="built_in">build</span>(<span class="number">0</span>,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BackOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">BackOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">BackOrder</span>(root-&gt;right);</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;pre&gt;&gt;in;</span><br><span class="line">    length=pre.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i]==in[j])&#123;</span><br><span class="line">                Hash[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//build hash</span></span><br><span class="line">    node* ROOT=<span class="built_in">buildTree</span>();</span><br><span class="line">    <span class="built_in">BackOrder</span>(ROOT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/07/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="clyfhaq4q00001487591p91dd" data-title="C++算法笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Web业务项目基本目录结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/08/Web%E4%B8%9A%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2024-02-08T12:16:26.000Z" itemprop="datePublished">2024-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/08/Web%E4%B8%9A%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/">Web业务项目基本目录结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>├── app ----------------------------- (项目文件)
    ├── api ------------------------- (对外接口)
    ├── global ---------------------- (全局组件对象)
    ├── internal -------------------- (内部逻辑)
        ├── middleware -------------- (中间件)
        ├── model ------------------- (模型层)
        ├── service ----------------- (服务层)
    ├── router ---------------------- (路由层)
├── manifest ------------------------ (交付清单)
   ├── deploy ----------------------- (部署配置文件)
      ├── docker -------------------- (docker配置文件)
      ├── kustomize ----------------- (k8s配置文件)
   ├── sql -------------------------- (mysql初始化配置文件)
├── utils/tools --------------------------- (工具包) 
├── build.sh ------------------------ (应用运行脚本)
├── docker-compolse.yml ------------- (容器构建配置)
├── go.mod -------------------------- (go依赖)
├── main.go ------------------------- (项目运行入口)
├── README.md ----------------------- (项目说明文档)
</code></pre>
<h4 id="对外接口-api"><a href="#对外接口-api" class="headerlink" title="对外接口 (api)"></a>对外接口 (api)</h4><p>服务接口的职责类似于三层架构设计中的<code>UI</code>表示层，负责接收并响应客户端的输入与输出，包括对输入参数的过滤、转换、校验，对输出数据结构的维护，并调用 <code>service</code> 实现业务逻辑处理。</p>
<h4 id="业务实现-service"><a href="#业务实现-service" class="headerlink" title="业务实现 (service)"></a>业务实现 (service)</h4><p>业务实现的职责类似于三层架构设计中的<code>BLL</code>业务逻辑层，负责具体业务逻辑的实现以及封装。</p>
<p>一是用于解耦业务模块之间的调用。</p>
<p>二是负责具体业务逻辑的实现以及封装。</p>
<h4 id="结构模型-model"><a href="#结构模型-model" class="headerlink" title="结构模型 (model)"></a>结构模型 (model)</h4><p><code>model</code>包的职责类似于三层架构中的<code>Model</code>模型定义层。模型定义代码层中仅包含全局公开的数据结构定义，往往不包含方法定义。</p>
<p>这里需要注意的是，这里的<code>model</code>不仅负责维护数据实体对象（<code>entity</code>）结构定义，也包括所有的输入&#x2F;输出数据结构定义，被<code>service</code>共同引用。这样做的好处除了可以统一管理公开的数据结构定义，也可以充分对同一业务领域的数据结构进行复用，减少代码冗余。</p>
<p>▐ 数据模型 - <code>entity</code></p>
<p>与数据集合绑定的程序数据结构定义，通常和数据表一一对应。</p>
<p>▐ 业务模型 - <code>model</code></p>
<p>与业务相关的通用数据结构定义，其中包含大部分的方法输入输出定义。</p>
<p>▐ 数据访问 - <code>dao</code></p>
<p><code>dao</code>的职责类似于三层架构中的<code>DAL</code>数据访问层，数据访问层负责所有的数据访问收口。</p>
<p>▐ <strong>cmd</strong></p>
<p><code>cmd</code>层负责<strong>引导程序启动</strong>，显著的工作是初始化逻辑、注册路由对象、启动<code>server</code>监听、阻塞运行程序直至<code>server</code>退出。</p>
<p>▐ <strong>api</strong></p>
<p>上层<code>server</code>服务<strong>接收客户端请求</strong>，转换为<code>api</code>中定义的<code>Req</code>接收对象、执行请求参数到<code>Req</code>对象属性的类型转换、执行<code>Req</code>对象中绑定的基础校验并转交<code>Req</code>请求对象给<code>controller</code>层。</p>
<p>▐ <strong>controller</strong></p>
<p><code>controller</code>层负责接收<code>Req</code>请求对象后<strong>做一些业务逻辑校验</strong>，随后调用一个或多个<code>service</code>实现业务逻辑，将执行结构封装为约定的<code>Res</code>数据结构对象返回。</p>
<p>▐ <strong>model</strong></p>
<p><code>model</code>层中<strong>管理所有的业务模型</strong>，<code>service</code>资源的<code>Input/Output</code>输入输出数据结构都由<code>model</code>层来维护。</p>
<p>▐ <strong>service</strong></p>
<p><code>service</code>是接口层，用于<strong>解耦业务模块</strong>，<code>service</code>没有具体的业务逻辑实现，具体的业务实现是依靠<code>logic</code>层注入的。</p>
<p>▐ <strong>logic</strong></p>
<p><code>logic</code>层的<strong>业务逻辑需要通过调用<code>dao</code>来实现数据的操作</strong>，调用<code>dao</code>时需要传递<code>do</code>数据结构对象，用于传递查询条件、输入数据。<code>dao</code>执行完毕后通过<code>Entity</code>数据模型将数据结果返回给<code>service</code>层。</p>
<p>▐ <strong>dao</strong></p>
<p><code>dao</code>层通过框架的<code>ORM</code>抽象层组件与底层真实的数据库交互</p>
<p><strong>如何清晰界定和管理<code>service</code>和<code>controller</code>的分层职责</strong></p>
<p><code>controller</code>层处理<code>Req/Res</code>外部接口请求。负责接收、校验请求参数，并调用<strong>一个或多个</strong> <code>service</code>来实现业务逻辑处理，根据返回数据结构组装数据再返回。<code>service</code>层处理<code>Input/Output</code>内部方法调用。负责内部<strong>可复用</strong>的业务逻辑封装，封装的方法粒度往往比较细。</p>
<p>在真实项目实践中，存在从<code>controller</code>层直接透传<code>Req</code>对象给<code>service</code>，同时<code>service</code>直接返回<code>Res</code>数据结构对象的情况。但当使用<code>service</code>方法处理特定的<code>Req</code>对象时，该方法也就与对于的外部接口耦合，仅为外部接口服务，难以复用。这样做会有一定的技术债务成本，具体成本需要自行具体衡量把握尺度。</p>
<p><strong>如何清晰界定和管理<code>service</code>和<code>dao</code>的分层职责</strong></p>
<p>这是一个很经典的问题。</p>
<p><strong>痛点：</strong></p>
<p>常见的，开发者把数据相关的业务逻辑实现封装到了<code>dao</code>代码层中，而<code>service</code>代码层只是简单的<code>dao</code>调用，这么做的话会使得原本负责维护数据的<code>dao</code>层代码越来越繁重，反而业务逻辑<code>service</code>层代码显得比较轻。开发者存在困惑，我写的业务逻辑代码到底应该放到<code>dao</code>还是<code>service</code>中？</p>
<p>业务逻辑其实绝大部分时候都是对数据的<code>CURD</code>处理，这样做会使得几乎所有的业务逻辑会逐步沉淀在<code>dao</code>层中，业务逻辑的改变其实会频繁对<code>dao</code>层的代码产生修改。例如：数据查询在初期的时候可能只是简单的逻辑，目前代码放到<code>dao</code>好像也没问题，但是查询需求增加或变化变得复杂之后，那么必定会继续维护修改原有的<code>dao</code>代码，同时<code>service</code>代码也可能同时做更新。原本仅限于<code>service</code>层的业务逻辑代码职责与<code>dao</code>层代码职责模糊不清、耦合较重，原本只需要修改<code>service</code>代码的需求变成了同时修改<code>service</code>+<code>dao</code>，使得项目中后期的开发维护成本大大增加。</p>
<p><strong>建议：</strong></p>
<p>我们的建议。<code>dao</code>层的代码应该尽量保证通用性，并且大部分场景下不需要增加额外方法，只需要使用一些通用的链式操作方法拼凑即可满足。业务逻辑、包括看似只是简单的数据操作的逻辑都应当封装到<code>service</code>中，<code>service</code>中包含多个业务模块，每个模块独自管理自己的<code>dao</code>对象，<code>service</code>与<code>service</code>之间通过相互调用方法来实现数据通信而不是随意去调用其他<code>service</code>模块的<code>dao</code>对象。</p>
<p><strong>为什么要使用<code>internal</code>目录包含业务代码</strong></p>
<p><code>internal</code>目录是<code>Golang</code>语言专有的特性，<strong>防止同级目录外的其他目录引用其下面的内容</strong>。业务项目中存在该目录的目的，是避免若项目中存在多个子项目（特别是大仓管理模式时），多个项目之间无限制随意访问，造成难以避免的多项目不同包之间耦合。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>每个公司、组织内部都有自己的组织方式，但每个项目都应该有一定的规范。虽然这种规范的约定没有那么强制，但是只要达成了一致之后，对于团队中组员快速理解和入门项目都是很有帮助的。有时候<strong>一些规范，就是团队的共同语言，定好了规范，减少了不必要的重复沟通，有利于提高整体的效率</strong>。</p>
<p>项目目录也一样，本篇文章讲的是参考 <a target="_blank" rel="noopener" href="https://github.com/golang-standards/project-layout">golang-standards</a> 提供的规范。但是，<strong>最重要的还是要与自己的团队商量，讨论并整理出适合自己的一套项目目录规范</strong>。</p>
<p><strong>一致的项目目录规范，有助于组员快速理解其他人的代码，不容易造成团队的”单点故障“；团队团结一致，共同维护和升级项目目录结构，可不断沉淀，不断提高效率，减少犯错</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/08/Web%E4%B8%9A%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" data-id="clyfhaq770005148784ob24g6" data-title="Web业务项目基本目录结构" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go Context包源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2023-12-01T03:01:25.000Z" itemprop="datePublished">2023-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Go Context包源码解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是context"><a href="#什么是context" class="headerlink" title="什么是context"></a>什么是context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context本质上是一个接口，实现这四个方法的都可以被称作context"><a href="#Context本质上是一个接口，实现这四个方法的都可以被称作context" class="headerlink" title="Context本质上是一个接口，实现这四个方法的都可以被称作context"></a>Context本质上是一个接口，实现这四个方法的都可以被称作context</h4><h5 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline()"></a>Deadline()</h5><p>返回time.Time类型的context过期时间，和一个布尔值ok。若ok为false则该context未设置过期时间 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Deadline())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">fmt.Println(c1.Deadline())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">0001</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC <span class="literal">false</span></span><br><span class="line"><span class="number">2023</span><span class="number">-11</span><span class="number">-28</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">59.2174603</span> +<span class="number">0800</span> CST m=+<span class="number">3.002624401</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h5><p>返回一个channel，当context关闭时，channel会关闭。如果context永远不会关闭，则会返回nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Done())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1.Done():</span><br><span class="line">   fmt.Println(<span class="string">&quot;context过期，channel关闭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context过期，channel关闭</span><br></pre></td></tr></table></figure>
<h5 id="Err"><a href="#Err" class="headerlink" title="Err()"></a>Err()</h5><p>返回一个error类型错误，没错误则返回nil，一般只有context超时和被关闭时则会返回error</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background()                      <span class="comment">//创建个空context</span></span><br><span class="line">c1, _ := context.WithTimeout(c, <span class="number">1</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">c2, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second)</span><br><span class="line">cancel()</span><br><span class="line">fmt.Println(c2.Err())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 （context超时和被取消的返回的error不一样）</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context deadline exceeded</span><br><span class="line">context canceled</span><br></pre></td></tr></table></figure>
<h5 id="Value-key-any"><a href="#Value-key-any" class="headerlink" title="Value(key any)"></a>Value(key any)</h5><p>类似map，输入key给出对应value。key通常在全局变量中分配，可返回任何类型的值。多次调用仍会返回相同值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">c1 := context.WithValue(c, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>) <span class="comment">//在context中设置一个键值对</span></span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Rose</span><br><span class="line">Rose</span><br><span class="line">Rose</span><br></pre></td></tr></table></figure>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><h5 id="取消错误"><a href="#取消错误" class="headerlink" title="取消错误"></a>取消错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当context被cancel函数关闭时调用<code>Err()</code>就会返回该错误</p>
<h5 id="超时错误"><a href="#超时错误" class="headerlink" title="超时错误"></a>超时错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此错误被集合成了一个结构体，通过调用其的三个方法来反映错误和获取信息</p>
<h2 id="EmptyContext"><a href="#EmptyContext" class="headerlink" title="EmptyContext"></a>EmptyContext</h2><h4 id="最简单的一个context"><a href="#最简单的一个context" class="headerlink" title="最简单的一个context"></a>最简单的一个context</h4><p>没有过期时间和信息，用来当作父context或者其他需求，通过其不断延伸</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="emptyCtx其他方法"><a href="#emptyCtx其他方法" class="headerlink" title="emptyCtx其他方法"></a>emptyCtx其他方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">   todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> e &#123;</span><br><span class="line">   <span class="keyword">case</span> background:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">   <span class="keyword">case</span> todo:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Background和Todo"><a href="#Background和Todo" class="headerlink" title="Background和Todo"></a>Background和Todo</h5><p>都是emptyCtx，本质上是一样，只是人为区分他们，将他们用作不同途径。  </p>
<ul>
<li>Background 返回一个非 nil、空的 Context。它永远不会被取消，没有价值，也没有截止日期。它通常由 main 函数、初始化和测试使用，并用作传入请求的顶级 Context。  </li>
<li>TODO 返回一个非 nil 的空 Context。代码应使用上下文。当不清楚要使用哪个 Context 或尚不可用时，就使用 TODO（因为周围函数尚未扩展为接受 Context 参数）。</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h5><p>该方法用来判断该emptyCtx是Background还是Todo</p>
<h2 id="cancel相关"><a href="#cancel相关" class="headerlink" title="cancel相关"></a>cancel相关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CancelCauseFunc <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CancelFunc与CancelCauseFunc"><a href="#CancelFunc与CancelCauseFunc" class="headerlink" title="CancelFunc与CancelCauseFunc"></a>CancelFunc与CancelCauseFunc</h5><ul>
<li>CancelFunc不需要参数</li>
<li>CancelCauseFunc需要error类型的参数<br>他们都是函数的别名，起别名是为了方便后面阅读和使用</li>
</ul>
<h5 id="WithCancel与WithCancelCause"><a href="#WithCancel与WithCancelCause" class="headerlink" title="WithCancel与WithCancelCause"></a>WithCancel与WithCancelCause</h5><ul>
<li>区别是Cause的携带</li>
<li>他们通过withCancel创建一个context，并返回该context和取消函数，下面以WithCancelCause为例，他返回如下的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br></pre></td></tr></table></figure>
cause是错误原因，然后这个函数调用新创建的cancelCtx的cancel方法，完成了取消操作。cancel需要参数如下，上面传入的第二个参数是<code>Canceled</code>，就是先前定义的一个错误<code>&quot;context canceled&quot;</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
后面再细讲cancel</li>
</ul>
<h2 id="创建cancelCtx"><a href="#创建cancelCtx" class="headerlink" title="创建cancelCtx"></a>创建cancelCtx</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withCancel</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   c := newCancelCtx(parent)</span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数需要一个父context，如果传入的是nil则会panic掉<br>继续往下看会发现出现新的函数<code>newCancelCtx</code>，我们看看它会传给我们什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给我们返回了一个包含父context的<code>cancelCtx</code>的指针，那么<code>cancelCtx</code>长什么样呢，继续跟过去</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">   done     atomic.Value          </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">   err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">   cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见里面有</p>
<ul>
<li><code>mu</code>：锁，用来保护临界资源</li>
<li><code>done</code>：atomic包里的value类型的值，原子性我们直接看看源码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Value 提供原子加载和一致类型化值的存储。</span></span><br><span class="line"><span class="comment">//Value 的零值从 Load 返回 nil。调用 Store 后，不得复制 Value。首次使用后不得复制 Value。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">   v any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>children</code>：字段是一个map，用于保存这个context派生出去的所有子context和它们对应的canceler。其中，<code>canceler</code>接口定义如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）"><a href="#canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）" class="headerlink" title="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）- err：错误信息- cause:错误原因（差不多吧这两个）    "></a><code>canceler</code>接口中有方法<code>cancel</code>，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的<code>cancel</code>方法将自己也取消掉，并将自己从父context的<code>children</code>字段中移除。<br>因此，<code>cancelCtx</code>中的<code>children</code>字段实际上是用来记录这个context的所有子context以及它们对应的<code>canceler</code>对象。当这个context被取消时，它会遍历所有的子context并调用它们的<code>cancel</code>方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）<br>- <code>err</code>：错误信息<br>- <code>cause</code>:错误原因（差不多吧这两个）    </h2><p>现在我们已经知道什么是cancelCtx了，那么回到原函数<code>withCanel</code>上来，<code>newCancelCtx</code>之后是<code>propagateCancel</code>函数，<strong>它的作用是将child添加到parent的children里面</strong>，让我们看看它的源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// parent永远无法取消则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第16行又出现了<code>parentCancelCtx</code>函数，该函数作用是查找最近的父cancelCtx</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>closedchan</code>在源码中是这样定义的，所以正如其名，他是个关闭的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"><a href="#所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下" class="headerlink" title="所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当&amp;cancelCtxKey作为参数则会返回该cancelCtx可是func (c *cancelCtx) Value(key any) any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"></a>所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false<br>之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br></pre></td></tr></table></figure><br>是什么含义呢？<br>我们再去看看Value方法是怎么处理这个的<br>经过查找我们发现cancelCtx重写了Value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当<code>&amp;cancelCtxKey</code>作为参数则会返回该cancelCtx<br>可是<code>func (c *cancelCtx) Value(key any) any</code>是如何获取到最近的canncelCtx呢？<br>如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx<br>如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>现在让我们回到<code>parentCancelCtx</code>函数上来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时已经通过parent.Value获取到了最近的cancelCtx并传给变量p了（没有找到就return nil了）<br>然后，通过p.done.Load()拿到一个管道（p.done是atomic.Value类型，在atomic包里有它的Load方法），<br>现在讲拿到的管道（最近的cancelCtx的管道）和之前的管道作比较（parent的管道），如果不是同一个就返回nil,<strong>这个情况代表你找到了最近的自定义cancelCtx但是并不是包定义的cancelCtx</strong>    </p>
<p>当一切都判定过去后，我们就成功拿到了最近的cancelCtx，现在我们终于可以回到<code>propagateCancel</code>函数了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// 如果分支上不存在可cancel的context则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到后先上个锁，再将child放到children的key里    </p>
<p><strong>那map中的值struct{}是拿来干什么？</strong><br>实际上是因为使用空结构体<code>struct&#123;&#125;</code>作为值的好处在于它占用极少的内存空间，实际上不占用任何空间。这是因为在Go语言中，空结构体的大小是0字节。通过将空结构体作为值，我们可以实现一个只关注键的集合，而不需要额外的内存开销。  </p>
<p>如果没有拿到，则开启一个协程来监听parent和child管道状态，若parent取消则child取消掉自己，若child先取消则不做为，当两个都没取消掉这个协程就会一直阻塞在这里，直到其中一个先cancel掉  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goroutines.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">   <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>到此为止，一个cancelCtx就被成功创建出来了</p>
<h2 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h2><p>直接看看源码，它的作用是，从最近的父cancelCtx的children中移除child</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   p, ok := parentCancelCtx(parent)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入一个父Ctx（不知道类型），然后根据此ctx查找最近的父cancelCtx，没有找到就return<br>找到就调用其锁，删掉children中的child这个key，再解锁  </p>
<h2 id="canceler定义"><a href="#canceler定义" class="headerlink" title="canceler定义"></a>canceler定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">   cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有cancel方法（后面讲）和Done方法的都是canceler，可以看到我们所有的cancelCtx都满足这个条件，所以每个cancelCtx实际上也是一个canceler</p>
<h2 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h2><p>cancelCtx的定义在之前已经提到过了，我们主要讲讲cancelCtx重写父Ctx的方法，就在代码旁批注解释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            </span><br><span class="line">   done     atomic.Value         </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">   err      <span class="type">error</span>                </span><br><span class="line">   cause    <span class="type">error</span>                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果传进来的key是实现设立的cancelCtxKey则返回该cancelCtx本身</span></span><br><span class="line"><span class="comment">//如果不是就会一直往上找，调用该ctx存储的父ctx的信息查看key对应value的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;   </span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">//done是atomic.Value类型，负责原子性存储</span></span><br><span class="line"><span class="comment">//先把done里的东西通过Load取出来</span></span><br><span class="line">   d := c.done.Load()     </span><br><span class="line">   <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;          </span><br><span class="line">      <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果done里啥都没有就上锁（关门打狗）</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//再次调用Load读取，目的是再次检查context有无被取消</span></span><br><span class="line">   d = c.done.Load()</span><br><span class="line">   <span class="comment">//done里确实啥也没有，就给他创建一个，然后存进去</span></span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;   </span><br><span class="line">      d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">      c.done.Store(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁读取err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   err := c.err</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String接口有关"><a href="#String接口有关" class="headerlink" title="String接口有关"></a>String接口有关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">   String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为接口定义，在各种string方法中均有contextName函数的出现，让我们看看这是什么吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contextName</span><span class="params">(c Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> s, ok := c.(stringer); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> s.String()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reflectlite.TypeOf(c).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将传入的<code>c</code>做类型断言，如果<code>c</code>是<code>stringer</code>接口类型就调用<code>c</code>的<code>String</code>方法<br>如果不是就返回用字符串表示的<code>c</code>的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123; 	</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">      c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">      time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">      reflectlite.TypeOf(c.key).String() +</span><br><span class="line">      <span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个String方法都是返回字符串类型的Ctx的信息</p>
<h2 id="cancel函数"><a href="#cancel函数" class="headerlink" title="cancel函数"></a>cancel函数</h2><p>这个函数已经在之前出现很多次了，现在我们来详细讲讲</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入err，则panic（可能是误操作的cancel，出现重大问题，直接panic掉）</span></span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; </span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果传入了err但是没有cause，就把err赋值给cause，原因就是err</span></span><br><span class="line">   <span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">      cause = err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//之后要对Ctx里的数据操作，先上把锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="comment">//如果Ctx已经被cancel掉就开锁退出</span></span><br><span class="line">   <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">   &#125;</span><br><span class="line">   c.err = err</span><br><span class="line">   c.cause = cause</span><br><span class="line">   <span class="comment">//关掉ctx中的管道</span></span><br><span class="line">   d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.done.Store(closedchan)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">close</span>(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历ctx的子ctx，一个一个取消，最后该分支下的全被取消掉</span></span><br><span class="line">   <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">      child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   &#125;</span><br><span class="line">   c.children = <span class="literal">nil</span></span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="comment">//是否要从父ctx移除该ctx，如果传入的是就移除</span></span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timerCtx</code>重写了该方法，主要通过调用父cancelCtx的cancel方法并删掉timer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.cancelCtx.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//它的锁是用的父cancelCtx的锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer.Stop()</span><br><span class="line">      c.timer = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   *cancelCtx</span><br><span class="line">   timer *time.Timer </span><br><span class="line"></span><br><span class="line">   deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建带有过期时间的Ctx"><a href="#创建带有过期时间的Ctx" class="headerlink" title="创建带有过期时间的Ctx"></a>创建带有过期时间的Ctx</h2><p>传入一个Ctx和时限，返回一个Ctx和取消它的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入parent，则报错</span></span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取parent过期时间，若获取成功且此时间在设定的时间之前，那么就听parent的话，与其同时过期</span></span><br><span class="line">   <span class="comment">//调用WithCancel，此函数会返回一个cancelCtx和取消函数</span></span><br><span class="line">   <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">      <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果没有获取到parent过期时间或者获取到的时间已经过了设定时间</span></span><br><span class="line">   <span class="comment">//就创建一个timerCtx，赋予过期时间为设定的时间</span></span><br><span class="line">   c := &amp;timerCtx&#123;</span><br><span class="line">      cancelCtx: newCancelCtx(parent),</span><br><span class="line">      deadline:  d,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建完后要填到parent的children里</span></span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   dur := time.Until(d)</span><br><span class="line">   <span class="comment">//如果已经超时，就cancel掉此ctx并从它的parent的children里移除</span></span><br><span class="line">   <span class="comment">//再返回该ctx（？？？不理解这点，拿这个剥离出来的cancel掉的ctx干啥）</span></span><br><span class="line">   <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//锁住这个ctx</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//如果该ctx还没被cancel就等到设定时间调用cancel</span></span><br><span class="line">   <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数就是WithDeadline的一个补充函数，它传入的是时间段，WithDeadline传入的是时间点，效果一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ValueCtx相关"><a href="#ValueCtx相关" class="headerlink" title="ValueCtx相关"></a>ValueCtx相关</h2><p>ValueCtx只负责携带Key-Value键值对，其他交给父Ctx做</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line">   key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建value"><a href="#创建value" class="headerlink" title="创建value"></a>创建value</h3><p>没啥好说的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查这个key能不能作比较，如果不能就不能拿它当key</span></span><br><span class="line">   <span class="comment">//为什么呢，因为如果key不能比较，我们就无法通过查找key来拿到对应的value</span></span><br><span class="line">   <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取value"><a href="#获取value" class="headerlink" title="获取value"></a>获取value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="comment">//能直接拿到就拿</span></span><br><span class="line">   <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">      <span class="keyword">return</span> c.val</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//不能就往上找</span></span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h3><p>这个就像一个方法合集，通过对传入的ctx类型判断来调用相应的方法，如果在当前ctx无法取到值就会一直往上找</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我第一次阅读源码，虽然context包很简单，但是我读起来真的好吃力<br>读着读着总会惊叹写这些代码的人脑子是怎么长的？vocal为什么能写的那么优雅，有些奇思妙想真的好牛 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clxsf5n7d00017c87an8hbogd" data-title="Go Context包源码解读" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go简单计算器的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-10-29T00:31:12.000Z" itemprop="datePublished">2023-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">Go简单计算器的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算器实现原理"><a href="#计算器实现原理" class="headerlink" title="计算器实现原理"></a>计算器实现原理</h2><p>我们平时见到的算式都是这种类型 <code>1+(2+3)*4</code>，这种类型的表达式也被称为中缀表达式，我们很容易理解它的运算顺序。但是计算机却无法理解这个式子<br>因此我们需要将其转化为便于计算机理解的式子，转化为后缀表达式或者前缀表达式（其实都差不多）。在这里我们以后缀表达式为例子。</p>
<h3 id="中缀表达式如何转化为后缀表达式"><a href="#中缀表达式如何转化为后缀表达式" class="headerlink" title="中缀表达式如何转化为后缀表达式"></a>中缀表达式如何转化为后缀表达式</h3><p><code>1+(2+3)*4</code>的后缀表达式为<code>123+4*+</code>，前者转换成后者的过程需要利用到栈和队列这两个数据结构，不太清楚可以看看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113852222">栈和队列详解</a>  </p>
<p>首先我们需要一个栈和队列</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81eab9f9deaf4aa0a489093ad592e77c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=602&s=62839&e=png&b=fdfdfd" alt="image.png"><br>然后从左到右依次根据一定规则判断是否入栈  </p>
<p>  入栈规则如下：  </p>
<ul>
<li><p>数字直接入队列</p>
</li>
<li><p>若是运算符，则判断其与栈顶符号的优先级，优先级低于或等于栈顶符号，栈内元素不断出栈，进入队列，直到栈空或者碰见左括号为止</p>
</li>
<li><p>若是左括号则直接入栈</p>
</li>
<li><p>若是右括号则栈内所有元素出栈，进入队列，直到遇见与之匹配的左括号</p>
</li>
<li><p>最后栈内所有元素按顺序入列</p>
<p>现在我们开始进行变换</p>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce14ec22c9b54ed29e7a625bbd614321~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=554&s=56982&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b332167d6864fc1b4fe540821e36187~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=559&s=56608&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be4fa1d786a42409fb3baf6711bba29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=923&h=587&s=57280&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2829f96842340779a589c8345b775d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=939&h=574&s=57307&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8cb753ed6264c2e82b3ab778fb50b36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=853&h=581&s=49855&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f7bf41a67f74a12adc2d8b53863fca5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=805&h=586&s=46212&e=png&b=fdfdfd" alt="image.png"><br>最后得到我们的结果<code>123+4*+</code>中缀就成功转化成后缀表达式了</p>
<h3 id="计算机是如何理解后缀表达式的？"><a href="#计算机是如何理解后缀表达式的？" class="headerlink" title="计算机是如何理解后缀表达式的？"></a>计算机是如何理解后缀表达式的？</h3><p>计算机会将之前放在队列里的元素按照先进先出(FIFO)的规则，将元素弹出进行判断<br>如果元素为数字，则直接入栈，若元素为运算符，则从栈中弹出两个数字进行运算，再将运算结果放入栈中<br>当队列全部元素取出后，最后栈中剩下的唯一一个元素就是我们要找的结果了</p>
<h2 id="在GO中的实现"><a href="#在GO中的实现" class="headerlink" title="在GO中的实现"></a>在GO中的实现</h2><p>首先我们需要创造出我们的工具：栈和队列</p>
<h3 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;      <span class="comment">//定义栈</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;  <span class="comment">//因为储存的元素是空接口类型，所以之后要注意类型断言和类型转化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;   <span class="comment">//返回一个栈</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断栈是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123; <span class="comment">//将元素入栈</span></span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将栈顶元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//只查询栈顶元素，不弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;       <span class="comment">//定义队列</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;   <span class="comment">//返回一个队列</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;   <span class="comment">//将元素压入队列</span></span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将最先进入的元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀转后缀实现"><a href="#中缀转后缀实现" class="headerlink" title="中缀转后缀实现"></a>中缀转后缀实现</h3><p>按照先前的规则，灵活运用判断语句实现中缀到后缀表达式的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算过程的实现"><a href="#计算过程的实现" class="headerlink" title="计算过程的实现"></a>计算过程的实现</h3><p>逻辑十分简单，主要注意的是类型间的转化，要从空接口类型断言为string类型，再将string类型转化为int类型进行计算，使用float类型也可以实现小数计算，可以自己去尝试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 实现栈</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue 实现队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterToNum</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   str := i.(<span class="type">string</span>)</span><br><span class="line">   ret, _ := strconv.Atoi(str)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;输入规则:&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;1.可输入加减乘除以及小括号&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;2.只能输入正整数&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;3.输入exit退出&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">      fmt.Printf(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line">      scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">      scanner.Scan() <span class="comment">// 读取输入内容，直到遇到换行符（包括空格）</span></span><br><span class="line">      input := scanner.Text()</span><br><span class="line">      <span class="keyword">if</span> input == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      S := NewStack()</span><br><span class="line">      Q := NewQueue()</span><br><span class="line">      err := Transform(S, Q, input)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">      ret := Calculate(S, Q)</span><br><span class="line">      fmt.Println(<span class="string">&quot;结果为: &quot;</span>, ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>以上只实现了正整数之间的加减乘除和小括号的运算，图方便未考虑其他可左右运算顺序的符号如：<code>[]中括号 &#123;&#125;大括号 %取余</code>，除此之外还可以尝试一下实现输入负数时处理的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clxsf5n7a00007c87g2xbft88" data-title="Go简单计算器的实现" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git合作开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-10T05:05:31.000Z" itemprop="datePublished">2023-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/">Git合作开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h3><p>用一个通俗的理解就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p>分支在实际开发中的作用：在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，到最后再合并分支，就可以达到很好的结果。</p>
<h3 id="master-主分支"><a href="#master-主分支" class="headerlink" title="master 主分支"></a>master 主分支</h3><p>在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master （也有叫main） 的分支。通常我们把这个master 分支叫做主分支。</p>
<p>在实际工作中，master （也有叫main）主分支的作用是：用来保存和记录整个项目已完成的功能代码。因此，不允许程序员直接在 master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p>
<h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>由于程序员不能直接在 master 分支上进行功能的开发，所以就有了功能分支的概念。功能分支指的是专门用来开发新功能的分支，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。</p>
<p>上面介绍了分支的一些概念之后，下面就开始进入本地分支操作</p>
<h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><h3 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>注意：分支名字前面的 * 号表示当前所处的分支。</p>
<h3 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h3><p>使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支的名字</span><br></pre></td></tr></table></figure>


<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>使用如下的命令，可以切换到指定的分支上进行开发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名字</span><br></pre></td></tr></table></figure>

<p>注意到前面的 * 号已经改变位置</p>
<h3 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h3><p>如果我们输入命令创建了一个分支之后，又要输入一个切换分支的命令，就很麻烦，所以使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名字</span><br></pre></td></tr></table></figure>

<p>PS：<br>“git checkout -b 分支名称” 是下面两条命令的简写形式：</p>
<ul>
<li>git branch 分支名称</li>
<li>git checkout 分支名</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//假如在C分支</span><br><span class="line">//先切换到A分支</span><br><span class="line">git checkout A</span><br><span class="line">//此时在A分支，合并A，C分支</span><br><span class="line">git merge C</span><br></pre></td></tr></table></figure>

<p>合并分支时的注意点：假设要把 C 分支的代码合并到 A 分支，则必须先切换到 A 分支上，再运行 git merge 命令，来合并 C 分支！</p>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后手动解决冲突。</p>
<p>举个栗子，我们再master分支上修改了test_01.txt文件，写入了一段文字，并提交</p>
<p>我们再切换到另一个分支也写一段文字，也提交</p>
<p>最后回到master分支上，去合并test分支，发现有提示冲突</p>
<p>且直接打开文件什么都看不到</p>
<p>我用vscode打开发现两端不同颜色的字体，其实就是不同分支写入的东西，需要我们认为去解决，看到上面有四个选项可以自己点击，如果点错了可以ctrl+z撤回再选。选完之后保存，然后跟踪提交再合并就不会有冲突了。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除分支</span><br><span class="line">git branch -d xxx</span><br></pre></td></tr></table></figure>


<p>注意，删除分支不能在该分支上删除该分支，就好比自己在一艘船上要把船弄沉这一道理。所以要去到其他分支再去删除</p>
<h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><h3 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a>将本地分支推送到远程仓库</h3><p>如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名 本地分支名称: 远程分支名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//案例</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"></span><br><span class="line">//如果希望远程分支的名称和本地分支名称保持一直，可以对命令进行简化：</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure>

<p>注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支</p>
<h3 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h3><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从远程仓库中，把对应的远程分支下载到本地仓库，名字保持一致</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"></span><br><span class="line">//从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"></span><br><span class="line">//案例  把远程仓库origin里面的pay分支下载并重命名为payment分支</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure>

<h3 id="拉取远程分支的最新的代码"><a href="#拉取远程分支的最新的代码" class="headerlink" title="拉取远程分支的最新的代码"></a>拉取远程分支的最新的代码</h3><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从远程仓库，拉区当前分支的最新代码，保持当前分支的代码和远程分支的代码一致</span><br><span class="line">git pull </span><br></pre></td></tr></table></figure>

<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>可以使用如下的命令，删除远程仓库中指定的分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line">//案例</span><br><span class="line">git push origin--delete pay</span><br></pre></td></tr></table></figure>

<h2 id="同步项目"><a href="#同步项目" class="headerlink" title="同步项目"></a>同步项目</h2><p>Github 我们经常会通过 fork 开源项目在自己的仓库中更新，然后提交 Pull Request (Merge Request) 为开源项目做贡献。</p>
<p>不过我们经常会遇到原仓库更新，重新 fork 显然是不优雅的，那我我们该怎么同步更新呢？</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f0a77dd7d7a47761846668fe061c70b_720w.webp"></p>
<h2 id="如何在-Github-网页端同步更新？"><a href="#如何在-Github-网页端同步更新？" class="headerlink" title="如何在 Github 网页端同步更新？"></a>如何在 Github 网页端同步更新？</h2><ol>
<li>进入你自己的 fork 过来的仓库。</li>
<li>点击 “Pull requests” ，如何点击右侧绿色的 “New pull request”。</li>
<li>Github 首先会比较源仓库与你 fork 后的仓库，如果你没有做任何更改，则找不到要 PR 的内容。所以，我们需要点击 “switching the base”，会将我们的仓库作为基础版本，原仓库作为 head 版本，现在我们会看到我们的需要需要 “catch up” 的更新。</li>
<li>点击 “Create pull request”，起一个名字，然后点击 “Create pull request”。</li>
<li>点击 “Merge pull request”，然后点击 “Confirm merge”。</li>
<li>如果我们没提交什么新代码，merge 过程将自动完成。</li>
</ol>
<h2 id="如何通过本地命令行同步更新？"><a href="#如何通过本地命令行同步更新？" class="headerlink" title="如何通过本地命令行同步更新？"></a>如何通过本地命令行同步更新？</h2><ol>
<li>验证远程分支可以 fetch 或 push</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指明我们需要同步的仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/OriginalRepo/OriginalProject.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>拉取更新的 branches 和 commits</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Checkout 本地分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>合并</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>提交</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/10/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/" data-id="clyfhaq4t00011487fgjnbxn5" data-title="Git合作开发" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/16/%E5%86%8D%E9%81%87%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">再遇跨域问题</a>
          </li>
        
          <li>
            <a href="/2024/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/">正则表达式笔记</a>
          </li>
        
          <li>
            <a href="/2024/06/29/go%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/">go算法小抄</a>
          </li>
        
          <li>
            <a href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/">TCPIP协议</a>
          </li>
        
          <li>
            <a href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/">一些想说的话</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Keiichi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>