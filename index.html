<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Keiichi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="My Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Keiichi&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Keiichi&#39;s blog">
<meta property="og:description" content="My Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keiichi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Keiichi's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keiichi&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TCPIP协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2024-06-25T03:00:10.000Z" itemprop="datePublished">2024-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/">TCPIP协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP协议是传输控制协议，即Transmission Control Protocol</p>
<p>基于TCP协议的有<code>HTTP（互联网）</code>、<code>SMTP（邮件）</code>、<code>POP3（邮件）</code>、<code>FTP（文件）</code>、<code>Talent（远程终端接入）</code></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>面向字节流</li>
<li>面向连接</li>
<li>全双工通信（双方可互相发送和接受信息）</li>
<li>可靠（三次握手四次挥手）</li>
<li>效率慢（需要三次握手建立连接）</li>
</ul>
<h2 id="报文段格式"><a href="#报文段格式" class="headerlink" title="报文段格式"></a>报文段格式</h2><p>TCP协议虽然面向字节流，但是传输的数据单元还是报文<img src="/a.png"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>本报文段所发送数据的第一个字节的序号</td>
<td>4字节</td>
</tr>
<tr>
<td>ACK(确认号)</td>
<td>期望收到对方下一个报文段的第一个数据字节的序号</td>
<td>若ACK&#x3D;N，则表明N-1前的数据正确收到</td>
</tr>
<tr>
<td>SYN(同步位)</td>
<td>连接建立时用同步序号</td>
<td>若SYN&#x3D;1,ACK&#x3D;0表示连接请求报文段<br>若SYN&#x3D;1,ACK&#x3D;1表示连接请求响应报文段</td>
</tr>
<tr>
<td>FIN(终止控制位)</td>
<td>释放连接</td>
<td>FIN&#x3D;1表示发送方数据发送完毕，请求释放连接</td>
</tr>
</tbody></table>
<h2 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/b.png"></p>
<ol>
<li>第一次：<code>客户端</code>向<code>服务器</code>发送一个请求连接的报文段（SYN&#x3D;1和一个随机的起始序号seq&#x3D;x）;此时报文段没有携带数据，<code>客户端</code>进入<code>同步已发送</code>状态<br><del>【客户端：兄弟给你发了个x，你看一下】</del></li>
<li>第二次：<code>服务器</code>接受到了<code>客户端</code>发送的报文后，向<code>客户端</code>发送响应报文（SYN&#x3D;1，ACK&#x3D;1）;此时<code>客户端</code><strong>为该TCP连接分配了TCP缓存和变量</strong><br><del>【服务器：收到兄弟，你发的是x吧？我给你x加个1再发给你，然后再随便发你个y，你注意查收】</del></li>
<li>第三次：<code>客户端</code>收到<code>服务器</code>发来的响应报文段后，再向<code>服务器</code>发送连接确认报文段（ACK&#x3D;1）;此时<code>服务端</code><strong>为该TCP连接分配TCP缓存和变量</strong><br><del>【客户端：奈斯兄嘚，知道你收到x还给我加1了，我也收到你发的y了，我也加1给你发过去】</del></li>
<li>已建立一条 TCP 连接，若在此期间未收到对方回复，会重新发送报文</li>
</ol>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><ul>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。<br>同时也可以防止服务器接收<strong>早已失效的请求</strong>，一直等待客户端的响应，形成死锁，造成资源浪费</p>
<h3 id="为什么不能二次握手"><a href="#为什么不能二次握手" class="headerlink" title="为什么不能二次握手"></a>为什么不能二次握手</h3><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，这是正常情况<br>如果客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，但是发出的确认号和建立连接后的确认号对不上，就会导致客户端会忽略服务端发来的确认请求。但由于是两次握手确认连接，服务端认为已经连接上了，就可以发送数据，但是客户端仍会忽略，造成资源浪费</p>
<h3 id="三次握手可以携带数据吗"><a href="#三次握手可以携带数据吗" class="headerlink" title="三次握手可以携带数据吗"></a>三次握手可以携带数据吗</h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p>
<h2 id="释放连接过程"><a href="#释放连接过程" class="headerlink" title="释放连接过程"></a>释放连接过程</h2><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/c.png"></p>
<ul>
<li>第一次：<code>客户端</code> 向<code>服务器</code>发送一个连接释放的报文段，并且<code>客户端</code>会停止再发送数据，等待<code>服务器</code>的确认</li>
<li>第二次：<code>服务器</code>收到连接释放报文后，向<code>客户端</code>发送连接释放确认报文段，至此，<code>客户端</code>–&gt;<code>服务器</code>的TCP连接已经断开了，处于半关闭状态</li>
<li>第三次 ：<code>服务器</code>如果已经没有要向<code>客户端</code>发送的数据，就会发送连接释放的报文段，<code>服务器</code>进入最终确认状态</li>
<li>第四次：<code>客户端</code>收到连接释放报文段后，就会向<code>服务器</code>发送连接释放确认的报文段，等待2msl之后<code>客户端</code>关闭，<code>服务器</code>收到之后就关闭。<code>服务器</code>关的比<code>客户端</code>早</li>
</ul>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>四次挥手是为了保证双方都能通知对方断开连接，也就是释放连接后，双方都不能接收或者发送消息给对方</p>
<p>第一次和第二次挥手，是<code>客户端</code>单方面宣布对<code>服务器</code>断开连接，此时<code>客户端</code>–&gt;<code>服务器</code>的连接断开，但是<code>服务器</code>–&gt;<code>客户端</code>的连接还未断开，TCP连接处于半关闭状态</p>
<p>第三次和第四次挥手，是<code>服务器</code>宣布对<code>客户端</code>断开连接，此时<code>服务器</code>–&gt;<code>客户端</code>的连接断开，第四次挥手后，双方才彻底断开连接</p>
<h3 id="为什么最后要等待2MSL的时间"><a href="#为什么最后要等待2MSL的时间" class="headerlink" title="为什么最后要等待2MSL的时间"></a>为什么最后要等待2MSL的时间</h3><p><code>MSL</code> &#x3D; 最长报文段寿命（<code>Maximum Segment Lifetime</code>）<br>等待2MSL可以保证客户端发送的最后1个连接释放确认报文 、能到达服务器，从而使得服务器能正常释放连接</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/" data-id="clxu1rpbv0000dc876vrqfb7m" data-title="TCPIP协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-一些想说的话" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/" class="article-date">
  <time class="dt-published" datetime="2024-06-23T07:13:15.000Z" itemprop="datePublished">2024-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/">一些想说的话</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><p>双非二本计算机专业就读，啥也不会</p>
<h2 id="开局"><a href="#开局" class="headerlink" title="开局"></a>开局</h2><p>我高中的目标就是计算机专业，想成为那种拿着键盘噼里啪啦一顿乱杀的超牛黑客（感觉大家都是这么认为的），但是事与愿违，我的高考成绩并不理想，进了目前学校的软件工程专业。到目前为止感觉也不是很坏，因为软件工程和计算机专业学的差不多，也能接触到编程。<br>但是学校无语的操作来了，刚入校就有一个特色班选拔，分别是英软和日软。我果断选择参加了英软的面试选拔，过了，结果莫名其妙被分到了日软，真服了。求助过辅导员，也是没什么用。最后想着是金子在哪都会发光（高中生莫名的自信，其实自己就是一坨），只有硬着头皮认了，进了日软班学习日语（进去后发现大部分哥们都是被莫名其妙坑进来的，心情顿时愉快了不少）。</p>
<h2 id="日语学习"><a href="#日语学习" class="headerlink" title="日语学习"></a>日语学习</h2><p>日语学起来不算很吃力，很好理解也很简单，就只是背的东西太多，变化的东西太多，不过我学的很认真，花了很多功夫去记忆，甚至还报了个校外的日语N2班。那段时间是很幸福的，能看见自己的日语水平正在以肉眼可见的速度增长着。感觉那时候应该是有N3的水平了吧（现在好久不碰都忘完了）</p>
<h2 id="转专业"><a href="#转专业" class="headerlink" title="转专业"></a>转专业</h2><p>我的均分和绩点是专业第二，所以有了转专业的机会，我考虑了很久要不要转去计算机专业，在深入了解后，我还是选择转去计算机专业。（真的考虑了好久好久，留下来继续学习可能有保研的机会，但是自己不知道能不能保持下去，而且自己的目标并不是读研，而是就业。转过去的话因为学习的课程学分差太多，需要留级一年，就会脱离目前熟悉的环境。我记得我当时连续两天都睡不着觉）</p>
<h2 id="工作室"><a href="#工作室" class="headerlink" title="工作室"></a>工作室</h2><p>大一的时候就加了红岩和蓝山工作室，接触了Go语言，了解了后端，也初步笃定了我以后的方向 <del>我要成为后端高手</del> 不过工作室的进度出奇快，每周一节课，一节课任务做一周，一节课的内容感觉是大学里C++课程一学期的进度（学校的进度真的很慢，一学期还在循环，连指针的影都见不到）</p>
<p>跟着学习了一年，不过因为我加入了其他的校级组织（勤工助学），每次工作室课程和组织活动的时间冲突，每周都要做一次二选一，时间也不太充裕 ，最后放弃了工作室那边的课程，花了大量时间组织活动上，现在很后悔。当时每组织一场活动，就能结识到许多人，而且也慢慢从内向变外向，当时是觉得，留在勤工更有用，成就感更大<del>而且每个月还有工资</del> 从现在看，实际上，这些组织活动的经历并不能给我带来什么<del>感觉是个人都能组织活动</del>，认识的那些“朋友”，也只是人生中的过客，除了加好友一开始聊的两句，之后再无联系。所以我很后悔，当初放下了后端学习</p>
<h2 id="留级"><a href="#留级" class="headerlink" title="留级"></a>留级</h2><p>我又变成了大一，心情是很复杂的，每次面对真正的大一都会很尴尬，不知道该用什么身份去交流，总会莫名其妙带入学长的身份说教，和目前同学的关系都不温不火，而且也不是住在一个寝室（转专业被发配到研究生寝室），交流的时间几乎为0</p>
<p>留级意味着有了更多充裕的时间，因为学过的课都不用再学了，所以我重新开始规划我的大一计划，先修了大二大三的部分课程，重新加入了蓝山工作室，留了勤工的负责人，充裕的时间被瞬间塞满（因为先修了很多门课，我上课时间其实和正常的大一大二学生差不多，甚至更多）</p>
<p>在上半学期，我是想重新牢固一下基础，于是就从最基础的算法开始学，也参加了一两个算法竞赛，都没拿到什么名次 （<del>我就是一坨</del> ），挫败感很强，不过好在通过了蓝山考核，又能留在蓝山了（其实是吃的之前老本，几乎没怎么跟着课程走）</p>
<h2 id="开始焦虑"><a href="#开始焦虑" class="headerlink" title="开始焦虑"></a>开始焦虑</h2><p>许多认识的人都去字节美团实习了，但自己感觉仍然没什么长进，也没有在后端有什么突破，只会简单的curd，我这一年到底在干嘛？急急急急急急急急急</p>
<h2 id="想要改变"><a href="#想要改变" class="headerlink" title="想要改变"></a>想要改变</h2><p>我真的需要改变，我没有沉下心来好好学某样东西，总是东学一点，西学一点，样样都拿不出手。我要好好学Go <del>我要成为后端高手</del> 不能再只喊着口号啥也不学了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/" data-id="clxsf5n7i00027c871hig6559" data-title="一些想说的话" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go Context包源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2023-12-01T03:01:25.000Z" itemprop="datePublished">2023-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Go Context包源码解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是context"><a href="#什么是context" class="headerlink" title="什么是context"></a>什么是context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context本质上是一个接口，实现这四个方法的都可以被称作context"><a href="#Context本质上是一个接口，实现这四个方法的都可以被称作context" class="headerlink" title="Context本质上是一个接口，实现这四个方法的都可以被称作context"></a>Context本质上是一个接口，实现这四个方法的都可以被称作context</h4><h5 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline()"></a>Deadline()</h5><p>返回time.Time类型的context过期时间，和一个布尔值ok。若ok为false则该context未设置过期时间 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Deadline())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">fmt.Println(c1.Deadline())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">0001</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC <span class="literal">false</span></span><br><span class="line"><span class="number">2023</span><span class="number">-11</span><span class="number">-28</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">59.2174603</span> +<span class="number">0800</span> CST m=+<span class="number">3.002624401</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h5><p>返回一个channel，当context关闭时，channel会关闭。如果context永远不会关闭，则会返回nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">fmt.Println(c.Done())</span><br><span class="line">c1, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1.Done():</span><br><span class="line">   fmt.Println(<span class="string">&quot;context过期，channel关闭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context过期，channel关闭</span><br></pre></td></tr></table></figure>
<h5 id="Err"><a href="#Err" class="headerlink" title="Err()"></a>Err()</h5><p>返回一个error类型错误，没错误则返回nil，一般只有context超时和被关闭时则会返回error</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background()                      <span class="comment">//创建个空context</span></span><br><span class="line">c1, _ := context.WithTimeout(c, <span class="number">1</span>*time.Second) <span class="comment">//加上时间限制，返回一个context和一个取消函数</span></span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">fmt.Println(c1.Err())</span><br><span class="line">c2, cancel := context.WithTimeout(c, <span class="number">3</span>*time.Second)</span><br><span class="line">cancel()</span><br><span class="line">fmt.Println(c2.Err())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 （context超时和被取消的返回的error不一样）</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">context deadline exceeded</span><br><span class="line">context canceled</span><br></pre></td></tr></table></figure>
<h5 id="Value-key-any"><a href="#Value-key-any" class="headerlink" title="Value(key any)"></a>Value(key any)</h5><p>类似map，输入key给出对应value。key通常在全局变量中分配，可返回任何类型的值。多次调用仍会返回相同值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := context.Background() <span class="comment">//创建个空context</span></span><br><span class="line">c1 := context.WithValue(c, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>) <span class="comment">//在context中设置一个键值对</span></span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">fmt.Println(c1.Value(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Rose</span><br><span class="line">Rose</span><br><span class="line">Rose</span><br></pre></td></tr></table></figure>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><h5 id="取消错误"><a href="#取消错误" class="headerlink" title="取消错误"></a>取消错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当context被cancel函数关闭时调用<code>Err()</code>就会返回该错误</p>
<h5 id="超时错误"><a href="#超时错误" class="headerlink" title="超时错误"></a>超时错误</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此错误被集合成了一个结构体，通过调用其的三个方法来反映错误和获取信息</p>
<h2 id="EmptyContext"><a href="#EmptyContext" class="headerlink" title="EmptyContext"></a>EmptyContext</h2><h4 id="最简单的一个context"><a href="#最简单的一个context" class="headerlink" title="最简单的一个context"></a>最简单的一个context</h4><p>没有过期时间和信息，用来当作父context或者其他需求，通过其不断延伸</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="emptyCtx其他方法"><a href="#emptyCtx其他方法" class="headerlink" title="emptyCtx其他方法"></a>emptyCtx其他方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">   todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> e &#123;</span><br><span class="line">   <span class="keyword">case</span> background:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">   <span class="keyword">case</span> todo:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Background和Todo"><a href="#Background和Todo" class="headerlink" title="Background和Todo"></a>Background和Todo</h5><p>都是emptyCtx，本质上是一样，只是人为区分他们，将他们用作不同途径。  </p>
<ul>
<li>Background 返回一个非 nil、空的 Context。它永远不会被取消，没有价值，也没有截止日期。它通常由 main 函数、初始化和测试使用，并用作传入请求的顶级 Context。  </li>
<li>TODO 返回一个非 nil 的空 Context。代码应使用上下文。当不清楚要使用哪个 Context 或尚不可用时，就使用 TODO（因为周围函数尚未扩展为接受 Context 参数）。</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h5><p>该方法用来判断该emptyCtx是Background还是Todo</p>
<h2 id="cancel相关"><a href="#cancel相关" class="headerlink" title="cancel相关"></a>cancel相关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CancelCauseFunc <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;</span><br><span class="line">   c := withCancel(parent)</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CancelFunc与CancelCauseFunc"><a href="#CancelFunc与CancelCauseFunc" class="headerlink" title="CancelFunc与CancelCauseFunc"></a>CancelFunc与CancelCauseFunc</h5><ul>
<li>CancelFunc不需要参数</li>
<li>CancelCauseFunc需要error类型的参数<br>他们都是函数的别名，起别名是为了方便后面阅读和使用</li>
</ul>
<h5 id="WithCancel与WithCancelCause"><a href="#WithCancel与WithCancelCause" class="headerlink" title="WithCancel与WithCancelCause"></a>WithCancel与WithCancelCause</h5><ul>
<li>区别是Cause的携带</li>
<li>他们通过withCancel创建一个context，并返回该context和取消函数，下面以WithCancelCause为例，他返回如下的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br></pre></td></tr></table></figure>
cause是错误原因，然后这个函数调用新创建的cancelCtx的cancel方法，完成了取消操作。cancel需要参数如下，上面传入的第二个参数是<code>Canceled</code>，就是先前定义的一个错误<code>&quot;context canceled&quot;</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
后面再细讲cancel</li>
</ul>
<h2 id="创建cancelCtx"><a href="#创建cancelCtx" class="headerlink" title="创建cancelCtx"></a>创建cancelCtx</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withCancel</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   c := newCancelCtx(parent)</span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数需要一个父context，如果传入的是nil则会panic掉<br>继续往下看会发现出现新的函数<code>newCancelCtx</code>，我们看看它会传给我们什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> *cancelCtx &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给我们返回了一个包含父context的<code>cancelCtx</code>的指针，那么<code>cancelCtx</code>长什么样呢，继续跟过去</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">   done     atomic.Value          </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">   err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">   cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见里面有</p>
<ul>
<li><code>mu</code>：锁，用来保护临界资源</li>
<li><code>done</code>：atomic包里的value类型的值，原子性我们直接看看源码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Value 提供原子加载和一致类型化值的存储。</span></span><br><span class="line"><span class="comment">//Value 的零值从 Load 返回 nil。调用 Store 后，不得复制 Value。首次使用后不得复制 Value。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">   v any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>children</code>：字段是一个map，用于保存这个context派生出去的所有子context和它们对应的canceler。其中，<code>canceler</code>接口定义如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）"><a href="#canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）-err：错误信息-cause-错误原因（差不多吧这两个）" class="headerlink" title="canceler接口中有方法cancel，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的cancel方法将自己也取消掉，并将自己从父context的children字段中移除。因此，cancelCtx中的children字段实际上是用来记录这个context的所有子context以及它们对应的canceler对象。当这个context被取消时，它会遍历所有的子context并调用它们的cancel方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）- err：错误信息- cause:错误原因（差不多吧这两个）    "></a><code>canceler</code>接口中有方法<code>cancel</code>，用于取消与之关联的context。当一个context的父context被取消时，它会调用自己的<code>cancel</code>方法将自己也取消掉，并将自己从父context的<code>children</code>字段中移除。<br>因此，<code>cancelCtx</code>中的<code>children</code>字段实际上是用来记录这个context的所有子context以及它们对应的<code>canceler</code>对象。当这个context被取消时，它会遍历所有的子context并调用它们的<code>cancel</code>方法，以便将它们也一并取消掉。（但是每个cancelCtx自身就满足了canceler接口的条件，也就是说他们自己就是canceler类型，不是很理解具体作用）<br>- <code>err</code>：错误信息<br>- <code>cause</code>:错误原因（差不多吧这两个）    </h2><p>现在我们已经知道什么是cancelCtx了，那么回到原函数<code>withCanel</code>上来，<code>newCancelCtx</code>之后是<code>propagateCancel</code>函数，<strong>它的作用是将child添加到parent的children里面</strong>，让我们看看它的源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// parent永远无法取消则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第16行又出现了<code>parentCancelCtx</code>函数，该函数作用是查找最近的父cancelCtx</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>closedchan</code>在源码中是这样定义的，所以正如其名，他是个关闭的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"><a href="#所以函数中如果parent-Done-返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent-Value-cancelCtxKey-并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当-cancelCtxKey作为参数则会返回该cancelCtx可是func-c-cancelCtx-Value-key-any-any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下" class="headerlink" title="所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义是什么含义呢？我们再去看看Value方法是怎么处理这个的经过查找我们发现cancelCtx重写了Value当&amp;cancelCtxKey作为参数则会返回该cancelCtx可是func (c *cancelCtx) Value(key any) any是如何获取到最近的canncelCtx呢？如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下"></a>所以函数中如果parent.Done()返回的是关闭的channel或者nil，说明最近cancelCtx已经被关闭，就返回nil和false<br>之后再通过parent.Value(&amp;cancelCtxKey)并进行类型断言获取值，可是cancelCtxKey在包中只有潦草的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br></pre></td></tr></table></figure><br>是什么含义呢？<br>我们再去看看Value方法是怎么处理这个的<br>经过查找我们发现cancelCtx重写了Value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当<code>&amp;cancelCtxKey</code>作为参数则会返回该cancelCtx<br>可是<code>func (c *cancelCtx) Value(key any) any</code>是如何获取到最近的canncelCtx呢？<br>如果parent本身是cancelCtx，则直接返回该parent，它就是最近的canncelCtx<br>如果不是，他会不断地调用上一级的value方法直到遇到canncelCtx返回为止，详见如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>现在让我们回到<code>parentCancelCtx</code>函数上来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">   done := parent.Done()</span><br><span class="line">   <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时已经通过parent.Value获取到了最近的cancelCtx并传给变量p了（没有找到就return nil了）<br>然后，通过p.done.Load()拿到一个管道（p.done是atomic.Value类型，在atomic包里有它的Load方法），<br>现在讲拿到的管道（最近的cancelCtx的管道）和之前的管道作比较（parent的管道），如果不是同一个就返回nil,<strong>这个情况代表你找到了最近的自定义cancelCtx但是并不是包定义的cancelCtx</strong>    </p>
<p>当一切都判定过去后，我们就成功拿到了最近的cancelCtx，现在我们终于可以回到<code>propagateCancel</code>函数了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   done := parent.Done()  <span class="comment">//获取父context的channel来检测父context是否能被取消</span></span><br><span class="line">   <span class="comment">//下面都用parent指代父context</span></span><br><span class="line">   <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>   <span class="comment">// 如果分支上不存在可cancel的context则退出</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:  <span class="comment">//监听</span></span><br><span class="line">      <span class="comment">// parent 已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent)) <span class="comment">//则child调用自身cancel方法取消自己</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">      p.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// parent has already been canceled</span></span><br><span class="line">         child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">            p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p.mu.Unlock()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goroutines.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">         <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到后先上个锁，再将child放到children的key里    </p>
<p><strong>那map中的值struct{}是拿来干什么？</strong><br>实际上是因为使用空结构体<code>struct&#123;&#125;</code>作为值的好处在于它占用极少的内存空间，实际上不占用任何空间。这是因为在Go语言中，空结构体的大小是0字节。通过将空结构体作为值，我们可以实现一个只关注键的集合，而不需要额外的内存开销。  </p>
<p>如果没有拿到，则开启一个协程来监听parent和child管道状态，若parent取消则child取消掉自己，若child先取消则不做为，当两个都没取消掉这个协程就会一直阻塞在这里，直到其中一个先cancel掉  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goroutines.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">      child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">   <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>到此为止，一个cancelCtx就被成功创建出来了</p>
<h2 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h2><p>直接看看源码，它的作用是，从最近的父cancelCtx的children中移除child</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">   p, ok := parentCancelCtx(parent)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">   &#125;</span><br><span class="line">   p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入一个父Ctx（不知道类型），然后根据此ctx查找最近的父cancelCtx，没有找到就return<br>找到就调用其锁，删掉children中的child这个key，再解锁  </p>
<h2 id="canceler定义"><a href="#canceler定义" class="headerlink" title="canceler定义"></a>canceler定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">   cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有cancel方法（后面讲）和Done方法的都是canceler，可以看到我们所有的cancelCtx都满足这个条件，所以每个cancelCtx实际上也是一个canceler</p>
<h2 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h2><p>cancelCtx的定义在之前已经提到过了，我们主要讲讲cancelCtx重写父Ctx的方法，就在代码旁批注解释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line"></span><br><span class="line">   mu       sync.Mutex            </span><br><span class="line">   done     atomic.Value         </span><br><span class="line">   children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">   err      <span class="type">error</span>                </span><br><span class="line">   cause    <span class="type">error</span>                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果传进来的key是实现设立的cancelCtxKey则返回该cancelCtx本身</span></span><br><span class="line"><span class="comment">//如果不是就会一直往上找，调用该ctx存储的父ctx的信息查看key对应value的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;   </span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">//done是atomic.Value类型，负责原子性存储</span></span><br><span class="line"><span class="comment">//先把done里的东西通过Load取出来</span></span><br><span class="line">   d := c.done.Load()     </span><br><span class="line">   <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;          </span><br><span class="line">      <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果done里啥都没有就上锁（关门打狗）</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//再次调用Load读取，目的是再次检查context有无被取消</span></span><br><span class="line">   d = c.done.Load()</span><br><span class="line">   <span class="comment">//done里确实啥也没有，就给他创建一个，然后存进去</span></span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;   </span><br><span class="line">      d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">      c.done.Store(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁读取err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   err := c.err</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String接口有关"><a href="#String接口有关" class="headerlink" title="String接口有关"></a>String接口有关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">   String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为接口定义，在各种string方法中均有contextName函数的出现，让我们看看这是什么吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contextName</span><span class="params">(c Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> s, ok := c.(stringer); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> s.String()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reflectlite.TypeOf(c).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将传入的<code>c</code>做类型断言，如果<code>c</code>是<code>stringer</code>接口类型就调用<code>c</code>的<code>String</code>方法<br>如果不是就返回用字符串表示的<code>c</code>的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123; 	</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">      c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">      time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">      reflectlite.TypeOf(c.key).String() +</span><br><span class="line">      <span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个String方法都是返回字符串类型的Ctx的信息</p>
<h2 id="cancel函数"><a href="#cancel函数" class="headerlink" title="cancel函数"></a>cancel函数</h2><p>这个函数已经在之前出现很多次了，现在我们来详细讲讲</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入err，则panic（可能是误操作的cancel，出现重大问题，直接panic掉）</span></span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; </span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果传入了err但是没有cause，就把err赋值给cause，原因就是err</span></span><br><span class="line">   <span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">      cause = err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//之后要对Ctx里的数据操作，先上把锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="comment">//如果Ctx已经被cancel掉就开锁退出</span></span><br><span class="line">   <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">   &#125;</span><br><span class="line">   c.err = err</span><br><span class="line">   c.cause = cause</span><br><span class="line">   <span class="comment">//关掉ctx中的管道</span></span><br><span class="line">   d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.done.Store(closedchan)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">close</span>(d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历ctx的子ctx，一个一个取消，最后该分支下的全被取消掉</span></span><br><span class="line">   <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">      child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   &#125;</span><br><span class="line">   c.children = <span class="literal">nil</span></span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">   <span class="comment">//是否要从父ctx移除该ctx，如果传入的是就移除</span></span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timerCtx</code>重写了该方法，主要通过调用父cancelCtx的cancel方法并删掉timer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">   c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">   <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">      removeChild(c.cancelCtx.Context, c)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//它的锁是用的父cancelCtx的锁</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer.Stop()</span><br><span class="line">      c.timer = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   *cancelCtx</span><br><span class="line">   timer *time.Timer </span><br><span class="line"></span><br><span class="line">   deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建带有过期时间的Ctx"><a href="#创建带有过期时间的Ctx" class="headerlink" title="创建带有过期时间的Ctx"></a>创建带有过期时间的Ctx</h2><p>传入一个Ctx和时限，返回一个Ctx和取消它的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="comment">//如果没有传入parent，则报错</span></span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取parent过期时间，若获取成功且此时间在设定的时间之前，那么就听parent的话，与其同时过期</span></span><br><span class="line">   <span class="comment">//调用WithCancel，此函数会返回一个cancelCtx和取消函数</span></span><br><span class="line">   <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">      <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果没有获取到parent过期时间或者获取到的时间已经过了设定时间</span></span><br><span class="line">   <span class="comment">//就创建一个timerCtx，赋予过期时间为设定的时间</span></span><br><span class="line">   c := &amp;timerCtx&#123;</span><br><span class="line">      cancelCtx: newCancelCtx(parent),</span><br><span class="line">      deadline:  d,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建完后要填到parent的children里</span></span><br><span class="line">   propagateCancel(parent, c)</span><br><span class="line">   dur := time.Until(d)</span><br><span class="line">   <span class="comment">//如果已经超时，就cancel掉此ctx并从它的parent的children里移除</span></span><br><span class="line">   <span class="comment">//再返回该ctx（？？？不理解这点，拿这个剥离出来的cancel掉的ctx干啥）</span></span><br><span class="line">   <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//锁住这个ctx</span></span><br><span class="line">   c.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">   <span class="comment">//如果该ctx还没被cancel就等到设定时间调用cancel</span></span><br><span class="line">   <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         c.cancel(<span class="literal">true</span>, DeadlineExceeded, <span class="literal">nil</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数就是WithDeadline的一个补充函数，它传入的是时间段，WithDeadline传入的是时间点，效果一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">   <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ValueCtx相关"><a href="#ValueCtx相关" class="headerlink" title="ValueCtx相关"></a>ValueCtx相关</h2><p>ValueCtx只负责携带Key-Value键值对，其他交给父Ctx做</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">   Context</span><br><span class="line">   key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建value"><a href="#创建value" class="headerlink" title="创建value"></a>创建value</h3><p>没啥好说的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">   <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查这个key能不能作比较，如果不能就不能拿它当key</span></span><br><span class="line">   <span class="comment">//为什么呢，因为如果key不能比较，我们就无法通过查找key来拿到对应的value</span></span><br><span class="line">   <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取value"><a href="#获取value" class="headerlink" title="获取value"></a>获取value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">   <span class="comment">//能直接拿到就拿</span></span><br><span class="line">   <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">      <span class="keyword">return</span> c.val</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//不能就往上找</span></span><br><span class="line">   <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h3><p>这个就像一个方法合集，通过对传入的ctx类型判断来调用相应的方法，如果在当前ctx无法取到值就会一直往上找</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *valueCtx:</span><br><span class="line">         <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.val</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *timerCtx:</span><br><span class="line">         <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.cancelCtx</span><br><span class="line">         &#125;</span><br><span class="line">         c = ctx.Context</span><br><span class="line">      <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> c.Value(key)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我第一次阅读源码，虽然context包很简单，但是我读起来真的好吃力<br>读着读着总会惊叹写这些代码的人脑子是怎么长的？vocal为什么能写的那么优雅，有些奇思妙想真的好牛 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clxsf5n7d00017c87an8hbogd" data-title="Go Context包源码解读" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go简单计算器的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-10-29T00:31:12.000Z" itemprop="datePublished">2023-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">Go简单计算器的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算器实现原理"><a href="#计算器实现原理" class="headerlink" title="计算器实现原理"></a>计算器实现原理</h2><p>我们平时见到的算式都是这种类型 <code>1+(2+3)*4</code>，这种类型的表达式也被称为中缀表达式，我们很容易理解它的运算顺序。但是计算机却无法理解这个式子<br>因此我们需要将其转化为便于计算机理解的式子，转化为后缀表达式或者前缀表达式（其实都差不多）。在这里我们以后缀表达式为例子。</p>
<h3 id="中缀表达式如何转化为后缀表达式"><a href="#中缀表达式如何转化为后缀表达式" class="headerlink" title="中缀表达式如何转化为后缀表达式"></a>中缀表达式如何转化为后缀表达式</h3><p><code>1+(2+3)*4</code>的后缀表达式为<code>123+4*+</code>，前者转换成后者的过程需要利用到栈和队列这两个数据结构，不太清楚可以看看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113852222">栈和队列详解</a>  </p>
<p>首先我们需要一个栈和队列</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81eab9f9deaf4aa0a489093ad592e77c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=602&s=62839&e=png&b=fdfdfd" alt="image.png"><br>然后从左到右依次根据一定规则判断是否入栈  </p>
<p>  入栈规则如下：  </p>
<ul>
<li><p>数字直接入队列</p>
</li>
<li><p>若是运算符，则判断其与栈顶符号的优先级，优先级低于或等于栈顶符号，栈内元素不断出栈，进入队列，直到栈空或者碰见左括号为止</p>
</li>
<li><p>若是左括号则直接入栈</p>
</li>
<li><p>若是右括号则栈内所有元素出栈，进入队列，直到遇见与之匹配的左括号</p>
</li>
<li><p>最后栈内所有元素按顺序入列</p>
<p>现在我们开始进行变换</p>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce14ec22c9b54ed29e7a625bbd614321~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=554&s=56982&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b332167d6864fc1b4fe540821e36187~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=559&s=56608&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be4fa1d786a42409fb3baf6711bba29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=923&h=587&s=57280&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2829f96842340779a589c8345b775d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=939&h=574&s=57307&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8cb753ed6264c2e82b3ab778fb50b36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=853&h=581&s=49855&e=png&b=fdfdfd" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f7bf41a67f74a12adc2d8b53863fca5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=805&h=586&s=46212&e=png&b=fdfdfd" alt="image.png"><br>最后得到我们的结果<code>123+4*+</code>中缀就成功转化成后缀表达式了</p>
<h3 id="计算机是如何理解后缀表达式的？"><a href="#计算机是如何理解后缀表达式的？" class="headerlink" title="计算机是如何理解后缀表达式的？"></a>计算机是如何理解后缀表达式的？</h3><p>计算机会将之前放在队列里的元素按照先进先出(FIFO)的规则，将元素弹出进行判断<br>如果元素为数字，则直接入栈，若元素为运算符，则从栈中弹出两个数字进行运算，再将运算结果放入栈中<br>当队列全部元素取出后，最后栈中剩下的唯一一个元素就是我们要找的结果了</p>
<h2 id="在GO中的实现"><a href="#在GO中的实现" class="headerlink" title="在GO中的实现"></a>在GO中的实现</h2><p>首先我们需要创造出我们的工具：栈和队列</p>
<h3 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;      <span class="comment">//定义栈</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;  <span class="comment">//因为储存的元素是空接口类型，所以之后要注意类型断言和类型转化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;   <span class="comment">//返回一个栈</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断栈是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123; <span class="comment">//将元素入栈</span></span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将栈顶元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//只查询栈顶元素，不弹出</span></span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;       <span class="comment">//定义队列</span></span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;   <span class="comment">//返回一个队列</span></span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;   <span class="comment">//将元素压入队列</span></span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;  <span class="comment">//将最先进入的元素记录并弹出</span></span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀转后缀实现"><a href="#中缀转后缀实现" class="headerlink" title="中缀转后缀实现"></a>中缀转后缀实现</h3><p>按照先前的规则，灵活运用判断语句实现中缀到后缀表达式的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算过程的实现"><a href="#计算过程的实现" class="headerlink" title="计算过程的实现"></a>计算过程的实现</h3><p>逻辑十分简单，主要注意的是类型间的转化，要从空接口类型断言为string类型，再将string类型转化为int类型进行计算，使用float类型也可以实现小数计算，可以自己去尝试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 实现栈</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span></span> *Stack &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Stack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   s.elements = <span class="built_in">append</span>(s.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   ret := s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   s.elements = s.elements[:<span class="built_in">len</span>(s.elements)<span class="number">-1</span>]</span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> top() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> s.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty stack&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.elements[<span class="built_in">len</span>(s.elements)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue 实现队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">   elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Queue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   q.elements = <span class="built_in">append</span>(q.elements, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> q.empty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;empty queue&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      r := ret.(<span class="type">string</span>)</span><br><span class="line">      <span class="built_in">println</span>(r)</span><br><span class="line">      q.elements = q.elements[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret := q.elements[<span class="number">0</span>]</span><br><span class="line">      q.elements = q.elements[<span class="number">1</span> : <span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterToNum</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   str := i.(<span class="type">string</span>)</span><br><span class="line">   ret, _ := strconv.Atoi(str)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(S *Stack, Q *Queue, input <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   temp := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="type">string</span>(input[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空，直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果栈不为空</span></span><br><span class="line">            m, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> m.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//前一个是左括号直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则全出</span></span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  t, _ := S.pop()</span><br><span class="line">                  Q.push(t.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> S.empty() &#123; <span class="comment">//如果栈为空直接入栈</span></span><br><span class="line">            S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之，将栈内元素弹出，放入队列</span></span><br><span class="line">            t, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> t.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> || t.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//栈顶为加减号或左括号，直接入栈</span></span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> &#123;</span><br><span class="line">                  j, _ := S.pop()</span><br><span class="line">                  Q.push(j.(<span class="type">string</span>))</span><br><span class="line">                  a, _ := S.top()</span><br><span class="line">                  <span class="keyword">if</span> S.empty() || a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;+&quot;</span> || a.(<span class="type">string</span>) == <span class="string">&quot;-&quot;</span> &#123; <span class="comment">//直到栈为空或者碰到左括号为止</span></span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">         <span class="comment">//别管，直接入栈</span></span><br><span class="line">         S.push(<span class="type">string</span>(input[i]))</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">         <span class="comment">//前面有数字堆着就先让数字入列</span></span><br><span class="line">         <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            Q.push(temp)</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">            j, _ := S.pop()</span><br><span class="line">            Q.push(j.(<span class="type">string</span>))</span><br><span class="line">            a, _ := S.top()</span><br><span class="line">            <span class="keyword">if</span> a.(<span class="type">string</span>) == <span class="string">&quot;(&quot;</span> &#123; <span class="comment">//直到碰到左括号为止,然后带走左括号</span></span><br><span class="line">               _, _ = S.pop()</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= input[i] &amp;&amp; input[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            temp += <span class="type">string</span>(input[i])</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;valid input&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若还有数字没有入队列就入</span></span><br><span class="line">   <span class="keyword">if</span> temp != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      Q.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若栈还有运算符就出栈</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> S.empty() &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      t, _ := S.pop()</span><br><span class="line">      Q.push(t.(<span class="type">string</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(S *Stack, Q *Queue)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Q.elements); i++ &#123;</span><br><span class="line">      t := Q.elements[i].(<span class="type">string</span>)</span><br><span class="line">      <span class="keyword">switch</span> t &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 + num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 - num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 * num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">         interNum1, _ := S.pop()</span><br><span class="line">         interNum2, _ := S.pop()</span><br><span class="line">         num1 := InterToNum(interNum1)</span><br><span class="line">         num2 := InterToNum(interNum2)</span><br><span class="line">         ret := num2 / num1</span><br><span class="line">         ret1 := strconv.Itoa(ret)</span><br><span class="line">         S.push(ret1)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         S.push(t)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i, _ := S.pop()</span><br><span class="line">   <span class="keyword">return</span> InterToNum(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;输入规则:&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;1.可输入加减乘除以及小括号&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;2.只能输入正整数&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;3.输入exit退出&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">      fmt.Printf(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line">      scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">      scanner.Scan() <span class="comment">// 读取输入内容，直到遇到换行符（包括空格）</span></span><br><span class="line">      input := scanner.Text()</span><br><span class="line">      <span class="keyword">if</span> input == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      S := NewStack()</span><br><span class="line">      Q := NewQueue()</span><br><span class="line">      err := Transform(S, Q, input)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">      ret := Calculate(S, Q)</span><br><span class="line">      fmt.Println(<span class="string">&quot;结果为: &quot;</span>, ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>以上只实现了正整数之间的加减乘除和小括号的运算，图方便未考虑其他可左右运算顺序的符号如：<code>[]中括号 &#123;&#125;大括号 %取余</code>，除此之外还可以尝试一下实现输入负数时处理的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clxsf5n7a00007c87g2xbft88" data-title="Go简单计算器的实现" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/25/TCPIP%E5%8D%8F%E8%AE%AE/">TCPIP协议</a>
          </li>
        
          <li>
            <a href="/2024/06/23/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/">一些想说的话</a>
          </li>
        
          <li>
            <a href="/2023/12/01/Go%20Context%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Go Context包源码解读</a>
          </li>
        
          <li>
            <a href="/2023/10/29/Go%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">Go简单计算器的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Keiichi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>